<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Articles-rsses on The long way through Software Craftsmanship</title>
    <link>https://alvarogarcia7.github.io/articles/index.xml</link>
    <description>Recent content in Articles-rsses on The long way through Software Craftsmanship</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 May 2019 22:32:19 +0000</lastBuildDate>
    <atom:link href="https://alvarogarcia7.github.io/articles/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Automatically keeping the intermediate history of your work using git</title>
      <link>https://alvarogarcia7.github.io/blog/2019/05/29/keeping-intermediate-history-work-git/</link>
      <pubDate>Wed, 29 May 2019 22:32:19 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2019/05/29/keeping-intermediate-history-work-git/</guid>
      <description>

&lt;p&gt;This is another tool for your toolbox: using git to automatically document your development process (special cases only.)&lt;/p&gt;

&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;

&lt;p&gt;When I&amp;rsquo;m spiking a feature, I usually get in the zone (e.g., Csikszentmihalyi&amp;rsquo;s Flow), and I can forget my good engineering practices, searching for that desired answer. After a few of those bouts of coding, you realize you&amp;rsquo;re wandering. You circle around, get lost, get back on track, then get lost again. You might or might not reach your goal.&lt;/p&gt;

&lt;p&gt;I sometimes lose the path that took me to the solution. This is helpful when you want to get back on your tracks (e.g., you broke something along the way). But I forget to commit as often as I should.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;p&gt;To document, I came up with a (very) simple tool to document the path:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
  date
  git add .
  git commit -am &lt;span class=&#34;s2&#34;&gt;&amp;quot;Automatic: Save progress&amp;quot;&lt;/span&gt;
  sleep &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This will create automatic (i.e., meaningless) commits every 10 seconds. It covers the need of &amp;ldquo;not forgetting to save the progress&amp;rdquo;. This script is so small, that there is no point in creating a tool around it. Type it as a one-liner when you need it.&lt;/p&gt;

&lt;p&gt;When you create meaningful increments (e.g., a milestone), when you decide that you should save your progress, you can commit as well. The downside is that the automatic commits will pollute your log, and the diff will not represent the full delta. For that, you can create a marker (i.e., one that does not have any diff - use the &lt;code&gt;allow-empty&lt;/code&gt; parameter). That kind of commit is like a &lt;a href=&#34;https://en.wikipedia.org/wiki/Marker_interface_pattern&#34; target=&#34;_blank&#34;&gt;Marker Interface Pattern&lt;/a&gt;, to pinpoint a specific delta:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span&gt;&lt;/span&gt;git commit -am &lt;span class=&#34;s2&#34;&gt;&amp;quot;Marker: Completed the ....&amp;quot;&lt;/span&gt; --allow-empty
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When you want to see all the changes, &lt;code&gt;git diff&lt;/code&gt; between two commits (e.g., Markers) or you can rebase with squash (&lt;code&gt;git rebase --interactive&lt;/code&gt;) into another branch (so you keep this history).&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Summary:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Automatic commits to save your progress. To save the progress.&lt;/li&gt;
&lt;li&gt;Manual commits to pinpoint milestones. To document.&lt;/li&gt;
&lt;li&gt;Tools help you be more productive&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Writing safe(r) bash scripts</title>
      <link>https://alvarogarcia7.github.io/blog/2018/07/13/writing-safe-bash-scripts/</link>
      <pubDate>Fri, 13 Jul 2018 07:03:19 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2018/07/13/writing-safe-bash-scripts/</guid>
      <description>

&lt;p&gt;After writing more and more bash scripts for a client, I&amp;rsquo;ve decided to write down my thoughts about it.&lt;/p&gt;

&lt;p&gt;This assumes you have some knowledge about bash, as it is not intended as a beginner&amp;rsquo;s tutorial.&lt;/p&gt;

&lt;h2 id=&#34;why-bash-scripts&#34;&gt;Why bash scripts?&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Bash is present in almost every unix/linux-based stack, now some Windows as well. An exception is the &amp;lsquo;alpine&amp;rsquo; docker images, which have a smaller, lighter shell (more on that later)&lt;/li&gt;
&lt;li&gt;Everything that you can automate, you can do from bash. Bash forces you to create a (first?) client for your application and see how the integration is from the user&amp;rsquo;s perspective&lt;/li&gt;
&lt;li&gt;Testing your application from bash forces you to treat your application as a black-box (e.g., different technology, no shared state, no access to internals)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;using-a-safe-bash-subset-sh&#34;&gt;Using a safe bash subset: sh&lt;/h3&gt;

&lt;p&gt;This is useful for &amp;lsquo;alpine&amp;rsquo; docker images, as some alpine do not include bash.&lt;/p&gt;

&lt;p&gt;The more general you need your script to be, the more you should prefer sh rather than bash. A source of generality can be making your script public (publish it), executing it under multiple environments, making it the installer for other tools, etc.&lt;/p&gt;

&lt;h2 id=&#34;tips&#34;&gt;Tips&lt;/h2&gt;

&lt;h3 id=&#34;temporary-files&#34;&gt;Temporary files&lt;/h3&gt;

&lt;p&gt;Do not assume that the current directory is the place for writing temporary files (or any file, for that matter).&lt;/p&gt;

&lt;p&gt;For temporary files, use &lt;code&gt;mktemp&lt;/code&gt;, and for directories &lt;code&gt;mktemp -d&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ man mktemp
MKTEMP(1)                 BSD General Commands Manual                MKTEMP(1)

NAME
     mktemp -- make temporary file name (unique)

DESCRIPTION
     The mktemp utility takes each of the given file name templates and over-
     writes a portion of it to create a file name.  This file name is unique
     and suitable for use by the application.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(remember to cleanup resources when your script exists - maybe use exit traps)&lt;/p&gt;

&lt;h3 id=&#34;exit-traps&#34;&gt;(Exit) Traps&lt;/h3&gt;

&lt;p&gt;There are some resources that you need to remove / cleanup / close at the end of your script. Both when things go well as when they don&amp;rsquo;t. Think of it as a (java) try-with-resources or try..catch..finally.&lt;/p&gt;

&lt;p&gt;Bash offers &lt;a href=&#34;https://www.gnu.org/software/bash/manual/bash.html#Bourne-Shell-Builtins&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;trap&lt;/code&gt;&lt;/a&gt; to perform this task:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trap arg signal
trap command signal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Taken from &lt;a href=&#34;https://bash.cyberciti.biz/guide/Trap_statement&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;An example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function finish {
  # Your cleanup code here
}
trap finish EXIT
trap finish SIGQUIT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information, and this example from &lt;a href=&#34;http://redsymbol.net/articles/bash-exit-traps/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;do-not-hardcode-the-shell-location&#34;&gt;Do not hardcode the shell location&lt;/h3&gt;

&lt;p&gt;This is more common with perl than with bash, as most bash installs are placed at &lt;code&gt;/bin/bash&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;/usr/bin/env bash&lt;/code&gt; / &lt;code&gt;/usr/bin/env sh&lt;/code&gt; to spawn a shell.&lt;/p&gt;

&lt;p&gt;Usage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash

#rest of commands
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;options-for-executing-header&#34;&gt;Options for executing / Header&lt;/h3&gt;

&lt;p&gt;add these options:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set -euxo pipefail
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These can be added anywhere, but I usually add them after the shebang (the beginning of the script)&lt;/p&gt;

&lt;p&gt;Reference: &lt;a href=&#34;https://www.gnu.org/software/bash/manual/bash.html#The-Set-Builtin&#34; target=&#34;_blank&#34;&gt;The set built-in&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Another reference: the inspiration for these options comes from &lt;a href=&#34;https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;a brief note:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set -e&lt;/code&gt; stops the execution if a command fails (this is the default behavior in &lt;code&gt;make&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set -u&lt;/code&gt;: Treat unset variables and parameters other than the special parameters ‘@’ or ‘*’ as an error when performing parameter expansion. An error message will be written to the standard error, and a non-interactive shell will exit.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set -x&lt;/code&gt;: debug. Trace the commands on the console&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set -o pipefail&lt;/code&gt;: make the pipe command fail if any of the commands in the pipe fail.

&lt;ul&gt;
&lt;li&gt;Example: with this option disabled, &lt;code&gt;a|b|c&lt;/code&gt; when &lt;code&gt;a&lt;/code&gt; fails, b will execute, the return value will be the one of &lt;code&gt;b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Example: with this option enabled, &lt;code&gt;a|b|c&lt;/code&gt; when &lt;code&gt;a&lt;/code&gt; fails, &lt;code&gt;b&lt;/code&gt; will not execute, the return value will be the one of &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you want to use a try&amp;hellip;catch pattern, disable &lt;code&gt;-e&lt;/code&gt; temporarily:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set +e # 1
ls NON_EXISTING_FILE # 2
set -e # 3
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;1: Disable error-checking. Note this is a plus (+) sign&lt;/li&gt;
&lt;li&gt;2: a command that could fail. As the error checking is disabled, the execution continues even if 2 throws an error. Therefore, the exception is swallowed.&lt;/li&gt;
&lt;li&gt;3: Enable error-checking again&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;debugging&#34;&gt;Debugging&lt;/h3&gt;

&lt;h4 id=&#34;enable-tracing-debugging-mode&#34;&gt;Enable tracing / debugging mode&lt;/h4&gt;

&lt;p&gt;I usually make my bash scripts as simple as possible (see Limitations), but even then, they fail often while building them.&lt;/p&gt;

&lt;p&gt;For that reason, you can enable the &amp;lsquo;debug&amp;rsquo; option permanently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Inside the script
set -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or just for one invocation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# When invoking the script
bash -x myscript.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: your script will get the parameters in the same fashion as if executing &lt;code&gt;./myscript.sh&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat myscript.sh
echo $1
$ ./myscript.sh 1
1
$ bash -x myscript.sh 1
+ echo 1
1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dry-run-while-building-the-script&#34;&gt;Dry-run while building the script&lt;/h4&gt;

&lt;p&gt;A common pattern I use while building scripts is to prepare the command but do not execute it yet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
# prepare options, decide what to do
echo COMMAND_WITH_SIDE_EFFECTS
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When I am sure that this is the desired command, usually after trying it manually on the console, I can remove the &lt;code&gt;echo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
# prepare options, decide what to do
COMMAND_WITH_SIDE_EFFECTS
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;dry-run-as-another-switch&#34;&gt;Dry-run as another switch&lt;/h4&gt;

&lt;p&gt;You can use the previous pattern but as a feature of your script:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Accept &amp;lsquo;-n / &amp;ndash;dry-run&amp;rsquo; (or similar)&lt;/li&gt;
&lt;li&gt;When the switch is enabled, it prepends &lt;code&gt;echo&lt;/code&gt; to your final command&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;COMMAND=&amp;quot;rm -rf ./.git&amp;quot;
if [ $DRY_RUN ]; then
  COMMAND=&amp;quot;echo $COMMAND&amp;quot;
fi

$COMMAND
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;verbosity-levels-and-other-modes&#34;&gt;Verbosity levels and other modes&lt;/h3&gt;

&lt;p&gt;When some scripts grow in size and are not a script but an application, being more or less verbose is useful.&lt;/p&gt;

&lt;p&gt;See &lt;code&gt;curl&lt;/code&gt; as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl localhost:8080
curl: (7) Failed to connect to localhost port 8080: Connection refused
$ curl -vvv localhost:8080
* Rebuilt URL to: localhost:8080/
*   Trying ::1...
* connect to ::1 port 8080 failed: Connection refused
*   Trying fe80::1...
* connect to fe80::1 port 8080 failed: Connection refused
*   Trying 127.0.0.1...
* connect to 127.0.0.1 port 8080 failed: Connection refused
* Failed to connect to localhost port 8080: Connection refused
* Closing connection 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Same with quiet mode, a mode to reduce verbosity.&lt;/p&gt;

&lt;p&gt;Same with &amp;lsquo;raw&amp;rsquo; mode, a mode to only print the raw output, maybe for consumption from another script.&lt;/p&gt;

&lt;h3 id=&#34;using-quotes&#34;&gt;Using quotes&lt;/h3&gt;

&lt;p&gt;Imagine a script that prints the first, second, and third received parameter, then all of them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat myscript.sh
echo &amp;quot;first=$1 second=$2 third=$3; all=$@&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The normal invocation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./myscript.sh 1 2 3
first=1 second=2 third=3; all=1 2 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(everything works as expected)&lt;/p&gt;

&lt;p&gt;now let&amp;rsquo;s try strings (with spaces)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./myscript.sh hello world
first=hello second=world third=; all=hello world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ok, bash uses spaces to delimit words. Now that we know this, lets be careful.&lt;/p&gt;

&lt;p&gt;We want to process some files (with spaces):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls file*
file 1.txt file 2.txt
$ ./myscript.sh $(ls file*)
first=file second=1.txt third=file; all=file 1.txt file 2.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A defect appeared: I want &amp;ldquo;file 1.txt&amp;rdquo; to be a parameter, not two.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s imagine a script checking whether a file exists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat file_exists.sh
if [ -e $1 ]; then # -e is for file exists; see `man test`
  echo &amp;quot;file $1 exists&amp;quot;
else
  echo &amp;quot;file $1 does not exist&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ ls file*
file 1.txt     file 2.txt     file_exists.sh
$ ./file_exists.sh &amp;quot;file 1.txt&amp;quot;
./file_exists.sh: line 1: [: file: binary operator expected
file file 1.txt does not exist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s add quotes to the test to make it work with spaces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat file_exists.sh
if [ -e &amp;quot;$1&amp;quot; ]; then # note the quotes
  echo &amp;quot;file $1 exists&amp;quot;
else
  echo &amp;quot;file $1 does not exist&amp;quot;
fi
$ ./file_exists.sh &amp;quot;file 1.txt&amp;quot;
file file 1.txt exists
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, be careful with spaces, as they mark the end of the string / parameter. Be proactive with quoting. From the &lt;a href=&#34;https://google.github.io/styleguide/shell.xml&#34; target=&#34;_blank&#34;&gt;google bash guide&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Always quote strings containing variables, command substitutions, spaces or shell meta characters, unless careful unquoted expansion is required.&lt;/li&gt;
&lt;li&gt;Prefer quoting strings that are &amp;ldquo;words&amp;rdquo; (as opposed to command options or path names).&lt;/li&gt;
&lt;li&gt;Never quote literal integers.&lt;/li&gt;
&lt;li&gt;Be aware of the quoting rules for pattern matches in [[.&lt;/li&gt;
&lt;li&gt;Use &amp;ldquo;$@&amp;rdquo; unless you have a specific reason to use $*.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Single quote does not interpolate: &lt;code&gt;&#39;$PATH&#39; is literally $PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Double quotes interpolate: &lt;code&gt;&amp;quot;$PATH&amp;quot; is the contents of the variable $PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If possible, try having spaces in the files you produce. It makes life much simpler.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;solid&#34;&gt;SOLID&lt;/h3&gt;

&lt;p&gt;If your script is a one-off thing, or will not suffer churn/modification, then feel free to discard this tip. On the other hand, if this script will be part of a critical path (e.g., deploying) or will be modified in the future, try to apply the SOLID principles that we apply for other pieces of software.&lt;/p&gt;

&lt;p&gt;Especially the SRP (below)&lt;/p&gt;

&lt;h3 id=&#34;single-responsibility-principle-srp&#34;&gt;Single Responsibility Principle (SRP)&lt;/h3&gt;

&lt;p&gt;I like to design my scripts by separating concerns or responsibilities.&lt;/p&gt;

&lt;p&gt;One typical example: process many files at once:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat s1.sh
#!/usr/bin/env bash

function find_files {
   while IFS= read -r -d &#39;&#39; file; do
       files+=( &amp;quot;$file&amp;quot; )
   done &amp;lt; &amp;lt;(find . -maxdepth 1 -type f -iname &amp;quot;file*.txt&amp;quot; -print0)
}

function process_file {
  file=&amp;quot;$1&amp;quot;
  echo &amp;quot;Will write to file $file&amp;quot;
}

function main {
  declare -a files # this is a global variable inside the script
  find_files
  for file in &amp;quot;${files[@]}&amp;quot;; do
    process_file &amp;quot;$file&amp;quot;
  done
}

main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The main benefit is that iterating the files is something that usually does not fail (just copy paste the script), while the main work is done in &lt;code&gt;process_file&lt;/code&gt;. The two functions have different pace of change, therefore two responsibilities. The latter, I can test manually (on the REPL) until it works, then copy-paste the script (see &amp;lsquo;How I write my scripts&amp;rsquo;).&lt;/p&gt;

&lt;p&gt;Its execution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls file*
file1.txt file2.txt
$ ./s1.sh
Will write to file ./file1.txt
Will write to file ./file2.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more information on return values and functions in bash, see &lt;a href=&#34;https://www.linuxjournal.com/content/return-values-bash-functions&#34; target=&#34;_blank&#34;&gt;this article&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;hot-swap-reload&#34;&gt;Hot-swap / reload&lt;/h3&gt;

&lt;p&gt;Files in bash are read every time you invoke them. So if you separate the &lt;code&gt;process_file&lt;/code&gt; function to another file, you can change the contents of it while the long-running main script is working.&lt;/p&gt;

&lt;h3 id=&#34;be-extra-careful-with-rm&#34;&gt;Be extra careful with &lt;code&gt;rm&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This is common knowledge, but it can happen to any of us.&lt;/p&gt;

&lt;p&gt;Removing files is a sharp-edged tool, such as &lt;code&gt;DELETE&lt;/code&gt; in SQL. This is why we &lt;code&gt;SELECT&lt;/code&gt; the same data set before deleting. Why we &lt;code&gt;ls&lt;/code&gt; files before &lt;code&gt;rm&lt;/code&gt;ing them.&lt;/p&gt;

&lt;p&gt;Some operating systems now protect &lt;code&gt;#rm -rf /&lt;/code&gt; with another flag, but the mistake of &lt;code&gt;#rm -rf $VARIABLE/*&lt;/code&gt; where &lt;code&gt;$VARIABLE&lt;/code&gt; is empty is common enough.&lt;/p&gt;

&lt;p&gt;To avoid the above mistake,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/env/bin bash
set -euxo pipefail
cd $VARIABLE #this will fail if $VARIABLE is unbound
rm -rf ./* # notice the dot (.) before the star
cd - #go back to the previous folder
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will only delete files from the current directory down (&lt;code&gt;./&lt;/code&gt;), yet another level of protection.&lt;/p&gt;

&lt;h3 id=&#34;static-code-analysis&#34;&gt;Static code analysis&lt;/h3&gt;

&lt;p&gt;Shell files can also be analyzed statically, (i.e., &lt;a href=&#34;https://en.wikipedia.org/wiki/Lint_(software)&#34; target=&#34;_blank&#34;&gt;lint&lt;/a&gt;). A tool for that is &lt;a href=&#34;https://www.shellcheck.net/&#34; target=&#34;_blank&#34;&gt;ShellCheck&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Shellcheck helps you locate possible errors, bugs, stylistic errors and suspicious constructs in your scripts.&lt;/p&gt;

&lt;p&gt;The tool is large enough to warrant another article, but the basic usage is straightforward: run the linter with the shell script as input.&lt;/p&gt;

&lt;p&gt;Some example run:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ shellcheck sh1.sh
In sh1.sh line 22:
  destination=${date}-$(basename $file)
                                 ^-- SC2086: Double quote to prevent globbing and word splitting.

In sh1.sh line 25:
  git add $file
          ^-- SC2086: Double quote to prevent globbing and word splitting.


In sh1.sh line 34:
  if [[ -z $(which imagemagick) ]]; then
             ^-- SC2230: which is non-standard. Use builtin &#39;command -v&#39; instead.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: I use the tool with docker (see &lt;a href=&#34;https://github.com/alvarogarcia7/shellcheck-docker&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;, &lt;a href=&#34;https://github.com/koalaman/shellcheck#installing&#34; target=&#34;_blank&#34;&gt;official docker image&lt;/a&gt;)&lt;/p&gt;

&lt;h2 id=&#34;how-i-write-my-scripts&#34;&gt;How I write my scripts&lt;/h2&gt;

&lt;p&gt;Usually, I design my scripts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the function &lt;code&gt;process_file&lt;/code&gt; to receive a single element (i.e., the function passed to &lt;code&gt;map&lt;/code&gt; / iterate). This is the hard part&lt;/li&gt;
&lt;li&gt;Create plumbing (either code or manual invocations), putting together the candidates with the other function.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-1-a-long-lived-script&#34;&gt;Example 1: a long-lived script&lt;/h3&gt;

&lt;p&gt;This is a full example with code to plumb the candidate to the function.&lt;/p&gt;

&lt;p&gt;I want to remove all the existing files in a directory that are greater in size than 30 KB. (I know this can be done with &lt;code&gt;find -exec&lt;/code&gt; or &lt;code&gt;ls | xargs rm&lt;/code&gt;, this is just an example for arbitrary logic).&lt;/p&gt;

&lt;p&gt;First, on the REPL, find all the files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh file*
-rw-r--r--  1 user  group     0B Jul 13 00:50 file1.txt
-rw-r--r--  1 user  group     0B Jul 13 00:50 file2.txt
-rw-r--r--  1 user  group   531K Jul 13 00:07 file3.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find files greater than the desired size:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find . -maxdepth 1 -type f -iname &amp;quot;file*.txt&amp;quot; -size +30k -print0
./file3.txt%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;now, only need to delete the file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function process_file {
  file=&amp;quot;$1&amp;quot;
  echo &amp;quot;rm $file&amp;quot; # 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: #1 - Notice the &lt;code&gt;echo&lt;/code&gt; command to protect the real execution&lt;/p&gt;

&lt;p&gt;First, I make sure that the plumbing code is all correct before executing commands with side effects (e.g., rm). If you are working with delicate data, you can consider working in a docker container.&lt;/p&gt;

&lt;p&gt;Then, remove the &amp;ldquo;temporary dry-run mode&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function process_file {
  file=&amp;quot;$1&amp;quot;
  rm $file
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat s2.sh
#!/usr/bin/env bash

function find_files {
   while IFS= read -r -d &#39;&#39; file; do
       files+=( &amp;quot;$file&amp;quot; )
   done &amp;lt; &amp;lt;(find . -maxdepth 1 -type f -iname &amp;quot;file*.txt&amp;quot; -size +30k -print0)
}

function process_file {
  file=&amp;quot;$1&amp;quot;
  rm $file
}

function main {
  declare -a files
  find_files
  for file in &amp;quot;${files[@]}&amp;quot;; do
    process_file &amp;quot;$file&amp;quot;
  done
}

main
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;example-2-a-one-off-script&#34;&gt;Example 2: a one-off script&lt;/h3&gt;

&lt;p&gt;This is a full example with a manual invocation to plumb the candidate to the function.:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the function &lt;code&gt;process_file&lt;/code&gt; to receive a single element (i.e., the function passed to &lt;code&gt;map&lt;/code&gt; / iterate).&lt;/li&gt;
&lt;li&gt;Manually, I will list all files / candidates to a temporary file&lt;/li&gt;
&lt;li&gt;Review the candidates&lt;/li&gt;
&lt;li&gt;(with vim) turn the selected candidates into invocations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First, on the REPL, find all the files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ls -lh file*
-rw-r--r--  1 user  group     0B Jul 13 00:50 file1.txt
-rw-r--r--  1 user  group     0B Jul 13 00:50 file2.txt
-rw-r--r--  1 user  group   531K Jul 13 00:07 file3.txt
-rw-r--r--  1 user  group   531K Jul 13 00:07 file_SUPER_IMPORTANT_DO_NOT_DELETE.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find files greater than the desired size:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ find . -maxdepth 1 -type f -iname &amp;quot;file*.txt&amp;quot; -size +30k &amp;gt; candidates.txt
$ cat candidates.txt
./file3.txt
./file_SUPER_IMPORTANT_DO_NOT_DELETE.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then, open vim to review, as a way of checking the valid candidates. This is the same process that &lt;code&gt;git rebase --interactive&lt;/code&gt; offers: a CLI command to rebase based on your editor.&lt;/p&gt;

&lt;p&gt;I realize that the file &lt;code&gt;file_SUPER_IMPORTANT_DO_NOT_DELETE.txt&lt;/code&gt; should not be deleted. So I remove that, manually.&lt;/p&gt;

&lt;p&gt;Now,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat candidates.txt
./file3.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then I prefer to edit the file manually than to create a script. Remember, this is a one-off effort. And programs need to be maintained. One-off scripts are to be thrown away, so no maintenance effort.&lt;/p&gt;

&lt;p&gt;Hint: the vim command &lt;code&gt;%s/^/rm /&lt;/code&gt; will insert at the beginning of the line the command &lt;code&gt;rm&lt;/code&gt; that we need. The command &lt;code&gt;%s/$/;/&lt;/code&gt; will append a semicolon at the end of the line. It&amp;rsquo;s not needed for this example, but as a reminder. This replacement can also be done with &lt;code&gt;sed&lt;/code&gt;/&lt;code&gt;awk&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat candidates.txt
rm ./file3.txt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, just execute this file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bash candidates.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And your files are processed. Gone, in this case.&lt;/p&gt;

&lt;h2 id=&#34;limitations&#34;&gt;Limitations&lt;/h2&gt;

&lt;p&gt;Every tool (and metaphor) has its limits. Know when to use a tool and when to change tools.&lt;/p&gt;

&lt;h3 id=&#34;when-is-bash-enough&#34;&gt;When is bash enough&lt;/h3&gt;

&lt;p&gt;Small scripts, simple invocations, etc.&lt;/p&gt;

&lt;p&gt;One-off tasks are perfect for bash: write code, review effects, throw it away. Don&amp;rsquo;t plan on reusing it. Although you can keep a collection of snippets for iterating, dealing with spaces, etc.&lt;/p&gt;

&lt;p&gt;More than 50-100 bash lines (a rough approximation), I consider a small program already. Maybe start thinking on building a better foundation around it.&lt;/p&gt;

&lt;h3 id=&#34;when-it-is-too-much-for-bash&#34;&gt;When it is too much for bash&lt;/h3&gt;

&lt;h4 id=&#34;complex-multi-stage-scripts&#34;&gt;Complex/multi-stage scripts&lt;/h4&gt;

&lt;p&gt;With my current knowledge of bash, I feel that some jobs are not appropriate for bash. For example, when dealing with spaces in strings, arrays, complex functions, etc.&lt;/p&gt;

&lt;p&gt;For that, I prefer a more powerful language, ideally scripting (so I can get a quick feedback cycle.) I&amp;rsquo;ve been playing with Perl lately (works very well), Ruby in the past. I&amp;rsquo;ve heard good things about typescript and go as well.&lt;/p&gt;

&lt;p&gt;Perl works well for powerful scripts that don&amp;rsquo;t need to be tested.&lt;/p&gt;

&lt;p&gt;Ruby works well for programs (no longer scripts) that need to be tested.&lt;/p&gt;

&lt;h4 id=&#34;parameter-autocompletion&#34;&gt;Parameter autocompletion&lt;/h4&gt;

&lt;p&gt;For my build scripts, I enjoy hitting &lt;code&gt;&amp;lt;tab&amp;gt;&lt;/code&gt; for auto-completion of the goals. Bash does not offer that out of the box (but can be performed using &lt;a href=&#34;https://www.gnu.org/software/bash/manual/bash.html#Programmable-Completion&#34; target=&#34;_blank&#34;&gt;programmable completion&lt;/a&gt;). Make, on the other hand, offers goal autocompletion out of the box:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.PHONY: build
build:
    ./gradlew build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, I can &lt;code&gt;make b&amp;lt;TAB&amp;gt;&lt;/code&gt; and it will suggest &lt;code&gt;make build&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;other-resources&#34;&gt;Other resources&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.shellcheck.net/&#34; target=&#34;_blank&#34;&gt;ShellCheck&lt;/a&gt; helps you check your shell scripts, using static analysis tools: ShellCheck is a GPLv3 tool that gives warnings and suggestions for bash/sh shell scripts.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/bash/manual/bash.html&#34; target=&#34;_blank&#34;&gt;Bash reference manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://google.github.io/styleguide/shell.xml&#34; target=&#34;_blank&#34;&gt;Google Bash reference guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Questioning the existing choices</title>
      <link>https://alvarogarcia7.github.io/blog/2018/07/04/questioning-existing-choices/</link>
      <pubDate>Wed, 04 Jul 2018 07:03:19 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2018/07/04/questioning-existing-choices/</guid>
      <description>

&lt;h2 id=&#34;context&#34;&gt;Context&lt;/h2&gt;

&lt;p&gt;For a client, we have worked on a service that works with files (containing sensitive data) that get corrupted very often.&lt;/p&gt;

&lt;p&gt;The use case is generally:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Two/Three file opens per day&lt;/li&gt;
&lt;li&gt;One modification per 10 file opens&lt;/li&gt;
&lt;li&gt;One corruption per 100 file opens&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;initial-solution&#34;&gt;Initial solution&lt;/h2&gt;

&lt;p&gt;The initial solution was just to copy the file (&lt;code&gt;file.txt&lt;/code&gt;) before opening, after closing. This results in two files (&lt;code&gt;YYY-MM-DDTHH-mm-ss_before_file.txt&lt;/code&gt;, &lt;code&gt;YYY-MM-DDTHH-mm-ss_after_file.txt&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;As this solution quickly became unmaintainable, the client developed a solution to hash the contents of the file and to remove the duplicated files.&lt;/p&gt;

&lt;p&gt;The original cost for developing this was high, as in-house software was needed for comparing the hashes of the files, for comparing the files (remember this is sensitive data). Even if this was just a script, the possibility of deleting correct data is just too much risk.&lt;/p&gt;

&lt;p&gt;Even if this was a pragmatic choice back then (as they did not realize about the cheaper solution), the danger of deleting data is still present as long as the old script is used. Maintainability wise, that script is simple enough but a defect could be potentially dangerous. (This is why the script for deleting the duplicated files does not actually delete files but generates a bash script for deleting them, which you can review before applying.)&lt;/p&gt;

&lt;h2 id=&#34;another-solution&#34;&gt;Another solution&lt;/h2&gt;

&lt;p&gt;When asked about this solution, the client mentioned that this was working well enough. Which is true.&lt;/p&gt;

&lt;p&gt;Another solution could be to store this file in a git repository and only commit the changes when there actually are changes to commit.&lt;/p&gt;

&lt;p&gt;The git repository solves both:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the problem of not having to delete data (as no duplicated data is generated)&lt;/li&gt;
&lt;li&gt;the cost of writing in-house software, as a single script to commit files is enough&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This client was using &lt;a href=&#34;https://en.wiktionary.org/wiki/if_it_ain%27t_broke,_don%27t_fix_it&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;if ain&amp;rsquo;t broke, don&amp;rsquo;t fix it&amp;rdquo;&lt;/a&gt;, with a good-enough solution.&lt;/p&gt;

&lt;p&gt;Not questioning the existing choice is expensive, putting you in a worse place that you could be. Questioning all the existing choices is expensive, and time-consuming (might lead to &lt;a href=&#34;https://en.wikipedia.org/wiki/Analysis_paralysis&#34; target=&#34;_blank&#34;&gt;analysis paralysis&lt;/a&gt;). Finding the sweet spot (whether to question or not), depends heavily on the context.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Support for out of hours on-call support</title>
      <link>https://alvarogarcia7.github.io/articles/2016/10/05/support-for-out-of-hours-on-call-support/</link>
      <pubDate>Wed, 05 Oct 2016 17:58:50 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/articles/2016/10/05/support-for-out-of-hours-on-call-support/</guid>
      <description>

&lt;p&gt;As the preface for the guide for on-call support, a positive note:&lt;/p&gt;

&lt;h2 id=&#34;readme&#34;&gt;README&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;You’re cool. I know it. Do not trust yourself, trust me that I trust you.&lt;/li&gt;
&lt;li&gt;You might be sleepy. It’s OK&lt;/li&gt;
&lt;li&gt;Everything is going to be fine. Take 5 minutes to think about anything, anytime. Especially before any rash decision.&lt;/li&gt;
&lt;li&gt;With great power comes great responsibility. Use it wisely.&lt;/li&gt;
&lt;li&gt;Restoring the services comes first, investigation comes second&lt;/li&gt;
&lt;li&gt;Do the very minimum of investigation after the incident (collect things that might disappear), leave the rest for the next day on office hours&lt;/li&gt;
&lt;li&gt;Whenever everything is done, go to sleep but keep an eye on your phone. Someone will contact if necessary&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thanks to &lt;a href=&#34;https://twitter.com/dhatanian&#34; target=&#34;_blank&#34;&gt;David Hatanian&lt;/a&gt; and another colleague for the feedback on this draft.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Refactoring functional code</title>
      <link>https://alvarogarcia7.github.io/articles/2016/09/28/refactoring-functional-code/</link>
      <pubDate>Wed, 28 Sep 2016 20:36:50 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/articles/2016/09/28/refactoring-functional-code/</guid>
      <description>&lt;p&gt;With my pairing mate we have refactored this piece of functional code.&lt;/p&gt;

&lt;p&gt;Original code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;filterTokens&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rawTokens&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cleanedTokens&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rawTokens&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cleanedTokens&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stopWordsArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;indexOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Refactored code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;filterTokens&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rawTokens&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cleanedTokens&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rawTokens&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startsWithADash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;removeDashFrom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;processedTokens&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cleanedTokens&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isNotEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isNotAStopWord&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;processedTokens&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startsWithADash&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;removeDashFrom&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;substring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isNotAStopWord&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stopWordsArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;indexOf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;===&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;isNotEmpty&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;token&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
 &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;These two codes do the same, but the second reads better, given that each small concept (e.g., &lt;code&gt;cleanedTokens&lt;/code&gt;) or operation (e.g., &lt;code&gt;removeDashFrom&lt;/code&gt;) has a name. Even the returned value, usually &lt;code&gt;result&lt;/code&gt;, has an appropiate name. The machine will optimize that variable assignment to a variable but the human reader will dig deeper only if required.&lt;/p&gt;

&lt;p&gt;Writing functional code should not be an excuse to forget about clean code. The two are independent variables.&lt;/p&gt;

&lt;p&gt;We have found that the second reads better than the first one, but we have reached this conclusion because we have similar values and practices.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Joys of the Craft as Article</title>
      <link>https://alvarogarcia7.github.io/articles/2014/12/15/the-joys-of-the-craft-as-article/</link>
      <pubDate>Mon, 15 Dec 2014 22:46:50 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/articles/2014/12/15/the-joys-of-the-craft-as-article/</guid>
      <description>&lt;p&gt;Quoting the book,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Why is programming fun? What delights may its practitioner expect as his reward?&lt;/p&gt;

&lt;p&gt;First is the sheer joy of making things. As the child delights in his mud pie, so the adult enjoys building things, especially things of his own design [&amp;hellip;]&lt;/p&gt;

&lt;p&gt;Second is the pleasure of making things that are useful to other people. Deep within, we want other to use our work and to find it helpful. [&amp;hellip;]&lt;/p&gt;

&lt;p&gt;Third is the fascination of fashioning complex puzzle-like objects of interlocking moving parts and watching them work in subtle cycles, playing out the consequences of principles built in from the beginning. [&amp;hellip;]&lt;/p&gt;

&lt;p&gt;Fourth is the joy of always learning, which springs from the nonrepeating nature of the task. In one way or another the problem is ever new, and its solver learns something: sometimes practical, sometimes theoretical, and sometimes both.&lt;/p&gt;

&lt;p&gt;Finally, there is the delight of working in such a tractable medium. The programmer, like the poet, works only slightly removed from the pure thought-stuff. He builds his castles in the air, from air, creating by exertion of the imagination. Few media of creating are so flexible, so easy to polish and rework, so readily capable of realizing grand conceptual structures. (As we shall see later, this very tractability has its own problems.)&lt;/p&gt;

&lt;p&gt;&lt;cite&gt;Frederick P. Brooks, Jr&lt;/cite&gt; in the &lt;a href=&#34;http://www.amazon.com/The-Mythical-Man-Month-Engineering-Anniversary/dp/0201835959&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;The Mythical Man-Month&amp;rdquo;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Update: &lt;a href=&#34;https://twitter.com/jmbeas&#34; target=&#34;_blank&#34;&gt;J.M. Beas&lt;/a&gt; did an awesome take on this subject on &lt;a href=&#34;http://blog.jmbeas.es/2010/11/01/por-que-programar-es-divertido/&#34; target=&#34;_blank&#34;&gt;his blog&lt;/a&gt; (Spanish)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>