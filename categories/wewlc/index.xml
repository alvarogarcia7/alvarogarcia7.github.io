<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wewlc on The long way through Software Craftsmanship</title>
    <link>https://alvarogarcia7.github.io/categories/wewlc/</link>
    <description>Recent content in Wewlc on The long way through Software Craftsmanship</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 18 Apr 2016 00:56:54 +0000</lastBuildDate>
    <atom:link href="https://alvarogarcia7.github.io/categories/wewlc/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Quote: Characterization tests</title>
      <link>https://alvarogarcia7.github.io/blog/2016/04/18/quote-characterization-tests/</link>
      <pubDate>Mon, 18 Apr 2016 00:56:54 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2016/04/18/quote-characterization-tests/</guid>
      <description>&lt;p&gt;In Working effectively with legacy code, Michael Feathers talks a type of tests to define or characterize the current behavior of the legacy system:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In nearly every legacy system, what the system does is more important than what it is supposed to do.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;characterization test&lt;/em&gt; is a test that characterizes the actual behavior of a piece of code. [&amp;hellip;] The test document the actual current behavior of the system. Here is a little algorithm for writing algorithm for writing characterization tests:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use a piece of code in a test harness&lt;/li&gt;
&lt;li&gt;Write an assertion that you know will fail&lt;/li&gt;
&lt;li&gt;Let the failure tell you what the behavior is.&lt;/li&gt;
&lt;li&gt;Change the test so that it expects the behavior that the code produces&lt;/li&gt;
&lt;li&gt;Repeat&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;M Feathers, in the chapter 13&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;, section &amp;ldquo;Characterization tests&amp;rdquo; of Working effectively with legacy code. Actual page, 186.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Later on, he goes to describe them in a bigger environment:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Characterization tests record the actual behavior of a piece of code. If we find something unexpected when we write them, it pays to get some clarification. It could be a bu. That doesn&amp;rsquo;t mean that we don&amp;rsquo;t include the test in our test suite; instead, we should mark it as suspicious an find out what th effect would be of fixing it.&lt;/p&gt;

&lt;p&gt;M Feathers, in the chapter 13&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:2&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:2&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, section &amp;ldquo;Characterization tests&amp;rdquo; of Working effectively with legacy code. Actual page, 188.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;Chapter 13, &amp;ldquo;I need to make a change, but I don&amp;rsquo;t know what tests to write&amp;rdquo;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;Chapter 13, &amp;ldquo;I need to make a change, but I don&amp;rsquo;t know what tests to write&amp;rdquo;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:2&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>What legacy code is about</title>
      <link>https://alvarogarcia7.github.io/blog/2015/04/21/what-legacy-code-is-about/</link>
      <pubDate>Tue, 21 Apr 2015 22:09:54 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2015/04/21/what-legacy-code-is-about/</guid>
      <description>&lt;p&gt;In his book &lt;a href=&#34;http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/ref=sr_1_1?ie=UTF8&amp;amp;qid=1429647115&amp;amp;sr=8-1&amp;amp;keywords=legacy+code+feathers&#34; target=&#34;_blank&#34;&gt;Working effectively with legacy code&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/mfeathers&#34; target=&#34;_blank&#34;&gt;Michael Feathers&lt;/a&gt; describes:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[&amp;hellip;] legacy code as code without tests. It is a good working definition, and it points to a solution [&amp;hellip;]&lt;/p&gt;

&lt;p&gt;M Feathers, in the preface of Working effectively with legacy code&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I really like this definition. It is objective and measurable. But this is also a downside. Let&amp;rsquo;s take any concurrent code, for example: you can achieve 100% coverage on a single thread and the program could have defects when executed in parallel. But this might be an outlier, as concurrency is difficult to test. Let&amp;rsquo;s take another example.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s a imagine a non-concurrent (i.e., single thread) code composed by a single class (no collaborators; just one responsibility; it is &amp;ldquo;Clean Code&amp;rdquo;, as defined per R.C. Martin&amp;rsquo;s book) that has some happy paths as well as some error-handling cases. As usual. The original code writer has decided to test only the happy paths. They deployed it to production, as the product was ready. You inherit this code.&lt;/p&gt;

&lt;p&gt;After the system is deployed to production, you start receiving defect reports on the happy paths (the tested part). The first one, you cross it off as an one-time thing. Then the second and third come. You take a deeper look and start seeing some inconsistencies in the tests, some tests that actually do not test anything interesting:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;some test the test framework&lt;/li&gt;
&lt;li&gt;some the language&lt;/li&gt;
&lt;li&gt;some test a happy path that works by pure luck&lt;/li&gt;
&lt;li&gt;some functionalities are tested (not all happy paths)&lt;/li&gt;
&lt;li&gt;there&amp;rsquo;s actually a defect converted into a specification (test) (??)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, I ask myself this question: when did I start considering this code as legacy? When I saw the bug reports in production (several in a row) or when I saw the poor suite of tests?&lt;/p&gt;

&lt;p&gt;I do think this codebase is legacy, no matter when I realized about it. But my first instinct would be to consider it legacy from the moment I received the bug reports, as I lost the trust in that code.&lt;/p&gt;

&lt;p&gt;Because for me, &lt;strong&gt;legacy code is about trust, not tests&lt;/strong&gt;. You can have tests but no trust; you can have trust but no tests (the latter is more difficult in non-trivial codebases.)&lt;/p&gt;

&lt;p&gt;This is why I would like to update the definition:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Legacy code is code without tests that provide trust to all your stakeholders&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The last part is very important, because the definition is no longer objective but depends from person to person. If the codebase doesn&amp;rsquo;t have tests, it is definitely legacy. But even if it has them, would you consider the given example a legacy or non-legacy code?&lt;/p&gt;

&lt;p&gt;These stakeholders include everyone affected or affecting the product: owners, developer team (in the scrum, wide sense), users, clients, &amp;hellip;&lt;/p&gt;

&lt;p&gt;Full disclosure: I&amp;rsquo;ve written plenty of legacy code. Code which I thought was good but really wasn&amp;rsquo;t. Even with tests, even with TDD, even with Clean Code. This has made me change my mind about what legacy code is all about.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Book: Diseño Ágil con TDD (Spanish)</title>
      <link>https://alvarogarcia7.github.io/blog/2015/02/02/book-dise%C3%B1o-%C3%A1gil-con-tdd-spanish/</link>
      <pubDate>Mon, 02 Feb 2015 21:32:21 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2015/02/02/book-dise%C3%B1o-%C3%A1gil-con-tdd-spanish/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;ve read this book &lt;a href=&#34;http://www.carlosble.com/libro-tdd/&#34; target=&#34;_blank&#34;&gt;Diseño Ágil con TDD&lt;/a&gt; (Spanish) by
&lt;a href=&#34;https://twitter.com/carlosble&#34; target=&#34;_blank&#34;&gt;Carlos Blé&lt;/a&gt; from cover to cover,
when previously I had only read the theoretical parts (Part I and Chapter 12 in Part II).&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s worth noting that this is the first TDD book in Spanish (I haven&amp;rsquo;t found any book in Spanish predating this one - also backed by the author; published in January 2010) and, as such, there are some translations that could be improved. Not that it makes it more difficult to read. Sometimes it&amp;rsquo;s a good idea to roughly translate concepts into English and then you&amp;rsquo;ll understand the point.&lt;/p&gt;

&lt;h2 id=&#34;first-part&#34;&gt;First part&lt;/h2&gt;

&lt;p&gt;The first part is very interesting, a theoretical introduction into TDD, ATDD and Agile methodologies. Points to some good books as a reference (e.g., Growing Object Oriented Software, Guided by Tests; Working Effectively with Legacy Code; Refactoring; etc)&lt;/p&gt;

&lt;p&gt;He explains the TDD algorithm (chapter 2) and the ATDD one (chapter 3). These two are maybe the two most important ones on the book. Should you read only a part of this book, I&amp;rsquo;d recommend to read the motivational intro (the fable on the preface) and these two.&lt;/p&gt;

&lt;p&gt;He gives excellent pieces of advice who, correctly applied, would set the basis for good software development, such as SOLID, Object Oriented Design (OOD), Inversion of Control (IoC), etc. (See chapter 7, &amp;ldquo;Diseño orientado a objetos&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a chapter (number 6) on &amp;ldquo;Mocks and other test doubles&amp;rdquo; (translation is mine)&lt;/p&gt;

&lt;h2 id=&#34;second-part&#34;&gt;Second part&lt;/h2&gt;

&lt;p&gt;The second part, as many other books where the source code is printed, was dense for me. Other books, such as &lt;a href=&#34;http://www.growing-object-oriented-software.com/&#34; target=&#34;_blank&#34;&gt;GOOS&lt;/a&gt;, show differences in content with bold typeface, to ease the reader&amp;rsquo;s task.  In my opinion, it would be useful to color the diffs, show them on the left and right, or even show the raw diff (e.g., &lt;code&gt;+++&lt;/code&gt; &lt;code&gt;---&lt;/code&gt;). I&amp;rsquo;m envisioning a typing program as LaTeX where you could specify a commit with its parent and a range of lines to output.&lt;/p&gt;

&lt;p&gt;The second part is written in C# and python, to show a TDD session with him. Warning: it&amp;rsquo;s much better in person than reading his book!&lt;/p&gt;

&lt;p&gt;The chapter 12 is a set of antipatterns you might find after starting with TDD. Even after you keep practicing TDD for a while, you will not get rid of these smells. Highly recommended.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s also an appendix on Continuous Integration, although there are better books for this.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Recommend this book if you are starting with TDD, or you are more advanced but it&amp;rsquo;s difficult for you to read in English.&lt;/p&gt;

&lt;p&gt;Always good as a refresher to read the theoretical part and the antipatterns&lt;/p&gt;

&lt;p&gt;PS: This book is free to read, published under a Creative Commons license (don&amp;rsquo;t know exactly which one)&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>