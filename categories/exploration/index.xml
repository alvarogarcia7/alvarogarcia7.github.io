<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The long way through Software Craftsmanship</title>
    <link>https://alvarogarcia7.github.io/categories/exploration/index.xml</link>
    <description>Recent content on The long way through Software Craftsmanship</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://alvarogarcia7.github.io/categories/exploration/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Exploring Testing with Java 8 Lambdas</title>
      <link>https://alvarogarcia7.github.io/blog/2015/07/30/exploring-testing-with-java-8-lambdas/</link>
      <pubDate>Thu, 30 Jul 2015 13:04:10 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2015/07/30/exploring-testing-with-java-8-lambdas/</guid>
      <description>

&lt;p&gt;At a client, we were testing a simple feature, but the resulting tests had much subtle repetition:&lt;/p&gt;

&lt;p&gt;(source code is &lt;a href=&#34;https://github.com/alvarogarcia7/spike-lambda-testing/tree/ef00a220f427900e3180dcbeec51248845446248&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;)&lt;/p&gt;
@Test
public void log_when_sending_greeting_letters() {

	sut.send(mock(GreetingLetter.class));

	verify(logger).sentGreetingLetter();
}

@Test
public void log_when_sending_love_letters() {

	sut.send(mock(LoveLetter.class));

	verify(logger).sentLoveLetter();
}

&lt;p&gt;and the production code:&lt;/p&gt;
public class MailSender {
	private final EventLogger eventLogger;

	public MailSender (final EventLogger eventLogger) {
		this.eventLogger = eventLogger;
	}

	public void send (final GreetingLetter letter) {
		// more business logic
		eventLogger.sentGreetingLetter();
	}

	public void send (final LoveLetter letter) {
		// more business logic
		eventLogger.sentLoveLetter();
	}
}

&lt;p&gt;Note: this is an adapted code, so the business logic is not complete and seems simple.&lt;/p&gt;

&lt;p&gt;So I decided to explore a bit on refactoring these tests to use lambdas and reduce repetition:&lt;/p&gt;
private MailSender sut;
private Consumer&lt;MailSender&gt; arrange;
private Consumer&lt;EventLogger&gt; verify;

@Test
public void log_greetings_letter() {
	arrange = (MailSender sut) -&gt; sut.send(mock(GreetingLetter.class));

	verify = EventLogger::sentGreetingLetter;

	assertAndVerify();
}

@Test
public void log_love_letter() {
	arrange = (MailSender sut) -&gt; sut.send(mock(LoveLetter.class));

	verify = EventLogger::sentLoveLetter;

	assertAndVerify();
}

private void assertAndVerify() {
	arrange.accept(sut);
	verify.accept(logger);
}

&lt;p&gt;Some comments, mine and my teammates:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The tests are not very readable, maybe because we&amp;rsquo;re still not used to java 8 lambdas&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assertAndVerify&lt;/code&gt; has multiple purposes / responsibilities&lt;/li&gt;
&lt;li&gt;The gain of usability does not outweight the loss of readability&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, the refactor was discarded and we are using the initial version.&lt;/p&gt;

&lt;p&gt;Later, in the dojo, &lt;a href=&#34;https://twitter.com/@trikitrok&#34; target=&#34;_blank&#34;&gt;Manuel&lt;/a&gt; and I have refactored this a little bit more. Source code is &lt;a href=&#34;https://github.com/alvarogarcia7/spike-lambda-testing/tree/8e3dbecd91e1ead33c5b3f6560e2a786c36b0de9&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
public class MailSenderShould {

	private EventLogger eventLogger;
	private MailSender mailSender;

	@Before
	public void setUp () {
		eventLogger = mock(EventLogger.class);
		mailSender = new MailSender(eventLogger);
	}

	@Test
	public void log_greetings_letter() {
		checkThat(aLoggingLine().forA(greetingLetter()).wasLoggedWhen(aGreetingLetterWasSent()));
	}

	@Test
	public void log_love_letter() {
		checkThat(aLoggingLine().forA(loveLetter()).wasLoggedWhen(aLoveLetterWasSent()));
	}

	private void checkThat (final Check check) {
		check.checkFor(mailSender, eventLogger);
	}

	private Consumer&lt;EventLogger&gt; aGreetingLetterWasSent () {
		return EventLogger::sentGreetingLetter;
	}

	private Consumer&lt;MailSender&gt; greetingLetter () {
		return (MailSender sut) -&gt; sut.sendGreetingLetter(mock(GreetingLetter.class));
	}

	private Consumer&lt;MailSender&gt; loveLetter () {
		return (MailSender sut) -&gt; sut.sendLoveLetter(mock(LoveLetter.class));
	}

	private Consumer&lt;EventLogger&gt; aLoveLetterWasSent () {
		return EventLogger::sentLoveLetter;
	}
}

&lt;p&gt;(the logger is &lt;a href=&#34;https://github.com/alvarogarcia7/spike-lambda-testing/blob/8e3dbecd91e1ead33c5b3f6560e2a786c36b0de9/src/test/java/com/example/lambdatesting/CheckBuilder.java&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Later, we have created a simpler functional DSL for the logging, joining the &lt;code&gt;act&lt;/code&gt; and &lt;code&gt;verify&lt;/code&gt; into an object called &lt;code&gt;Check&lt;/code&gt;&lt;/p&gt;
public class MailSenderShould {

	private EventLogger eventLogger;
	private MailSender mailSender;

	@Before
	public void setUp () {
		eventLogger = mock(EventLogger.class);
		mailSender = new MailSender(eventLogger);
	}

	@Test
	public void log_greetings_letter() {
		mailSenderLogs(whenSendingAGreetingLetter());
	}

	@Test
	public void log_love_letter() {
		mailSenderLogs(whenSendingALoveLetter());
	}

	private Check whenSendingALoveLetter () {
		return new Check(
			(MailSender sut) -&gt; sut.send(letter(LoveLetter.class)),
			EventLogger::sentLoveLetter
		);
	}

	private void mailSenderLogs (Check check) {
		check.checkFor(mailSender, eventLogger);
	}

	private Check whenSendingAGreetingLetter () {
		return new Check(
			(MailSender sut) -&gt; sut.send(letter(GreetingLetter.class)),
			EventLogger::sentGreetingLetter
		);
	}

	private &lt;T&gt; T letter (final Class&lt;T&gt; typeOfLetter) {
		return mock(typeOfLetter);
	}
}

&lt;p&gt;and the &lt;code&gt;Check&lt;/code&gt;, just a placeholder for two &lt;code&gt;Consumer&lt;/code&gt;s:&lt;/p&gt;
public class Check {

	private final Consumer&lt;MailSender&gt; act;
	private final Consumer&lt;EventLogger&gt; verify;

	public Check (final Consumer&lt;MailSender&gt; act, final Consumer&lt;EventLogger&gt; verify) {
		this.act = act;
		this.verify = verify;
	}

	public void checkFor(MailSender mailSender, EventLogger eventLogger) {
		act.accept(mailSender);
		verify.accept(eventLogger);
	}
}

&lt;h2 id=&#34;comparison&#34;&gt;Comparison&lt;/h2&gt;

&lt;p&gt;Comparison between the original form and the three refactored forms of the test:&lt;/p&gt;
@Test
public void log_when_sending_greeting_letters() {

	sut.send(mock(GreetingLetter.class));

	verify(logger).sentGreetingLetter();
}

&lt;p&gt;This reads like a classical JUnit tests, using the interaction (with mocks).&lt;/p&gt;
@Test
public void log_greetings_letter() {
	arrange = (MailSender sut) -&gt; sut.send(mock(GreetingLetter.class));

	verify = EventLogger::sentGreetingLetter;

	assertAndVerify();
}

&lt;p&gt;This is the first step towards more cohesion, at the cost of readability. You save the verify at the end, but the repeated method &lt;code&gt;assertAndVerify&lt;/code&gt; is still present.&lt;/p&gt;
@Test
public void log_greetings_letter() {
	checkThat(aLoggingLine().forA(greetingLetter()).wasLoggedWhen(aGreetingLetterWasSent()));
}

&lt;p&gt;This one reads more like a classical DSL, but is harder to read compared to a classical test.&lt;/p&gt;
@Test
public void log_greetings_letter() {
	mailSenderLogs(whenSendingAGreetingLetter());
}

&lt;p&gt;This one reads more like a business requirement.&lt;/p&gt;

&lt;h2 id=&#34;other&#34;&gt;Other&lt;/h2&gt;

&lt;p&gt;Other ideas we have tested:&lt;/p&gt;
Builder.aNew().sendGreetingLetter()

assertAndVerifyThat(
	theLoggingLine()
		.for(aGreetingLetter())
		.isLoggedWhen(greetingLetterIsSent()
	)
);

public Consumer&lt;MailSender&gt; aGreetingLetter(){
	return (MailSender sut) -&gt; sut.sendGreetingLetter(mock(GreetingLetter.class));
}

public Consumer&lt;EventLogger&gt; greetingLetterIsSent(){
	return EventLogger::sentGreetingLetter;
}
assertAndVerifyThat(
	theLoggingLine()
		.for(
			(MailSender sut) -&gt; sut.sendGreetingLetter(mock(GreetingLetter.class))
		)
		.isLoggedWhen(EventLogger::sentGreetingLetter)
	)
);
public void assertAndVerifyThat(TestContext testContext){
	testContext.assert();
	testContext.verify();
}
</description>
    </item>
    
  </channel>
</rss>