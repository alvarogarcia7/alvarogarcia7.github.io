<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The long way through Software Craftsmanship</title>
    <link>https://alvarogarcia7.github.io/categories/macro-vs-function/index.xml</link>
    <description>Recent content on The long way through Software Craftsmanship</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://alvarogarcia7.github.io/categories/macro-vs-function/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Clojure and the macro and</title>
      <link>https://alvarogarcia7.github.io/blog/2015/12/08/clojure-and-the-macro-and/</link>
      <pubDate>Tue, 08 Dec 2015 17:37:28 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2015/12/08/clojure-and-the-macro-and/</guid>
      <description>

&lt;p&gt;While on the REPL, I tried this:&lt;/p&gt;
simple.core=&gt; (reduce and true [true])
CompilerException java.lang.RuntimeException: Can&#39;t take value of a macro: #&#39;clojure.core/and, compiling:(form-init7116694665186998245.clj:1:1)

&lt;p&gt;Reading the &lt;a href=&#34;https://clojuredocs.org/clojure.core/and&#34; target=&#34;_blank&#34;&gt;clojuredocs for &lt;code&gt;and&lt;/code&gt;&lt;/a&gt;, you can find this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note add is a macro, so you cannot apply it. For example, there is a vector of some Boolean values [true true false true], which you want to test to see if they are all true. The code below will not work:&lt;/p&gt;

&lt;p&gt;(apply add [true true false true]) ;won&amp;rsquo;t work&lt;/p&gt;

&lt;p&gt;Instead, use this:&lt;/p&gt;

&lt;p&gt;(every? identity [true  true false true])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I tried it with success. Digging a bit deeper:&lt;/p&gt;
simple.core=&gt; (defn all-truthy? [&amp; elements] (every? identity elements))
#&#39;simple.core/all-truthy?
simple.core=&gt; (all-truthy? nil false)
false
simple.core=&gt; (all-truthy? nil 0)
false
simple.core=&gt; (all-truthy? nil 1)
false
simple.core=&gt; (all-truthy? 2 1)
true
simple.core=&gt; (all-truthy? [nil false])
true

&lt;p&gt;Was also tempted to try this:&lt;/p&gt;
simple.core=&gt; (reduce (fn [acc element] (and acc element)) true [true true false true])
false
simple.core=&gt; (reduce (fn [acc element] (and acc element)) true [true true true true])
true

&lt;p&gt;Encapsulate it into a function:&lt;/p&gt;
simple.core=&gt; (defn all-true [&amp; elements] (reduce (fn [acc element] (and acc element)) true elements))
#&#39;simple.core/all-true
simple.core=&gt; (all-true true)
true
simple.core=&gt; (all-true true false)
false
simple.core=&gt; (all-true true false true)
false

&lt;p&gt;What happens with the non-boolean values?&lt;/p&gt;
simple.core=&gt; (all-true 1 2 3)
3
simple.core=&gt; (all-true 1 2 3 76)
76
simple.core=&gt; (all-true 1 2 3 64)
64
simple.core=&gt; (all-true 1 2 3 64)
64

&lt;p&gt;This is because:&lt;/p&gt;
simple.core=&gt; (and 64 3)
3
simple.core=&gt; (and 3 64)
64

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;all-truthy?&lt;/code&gt; exploits the falsy values in clojure (&lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;), while &lt;code&gt;all-true&lt;/code&gt; uses the true boolean values, although the function does not work properly with non-boolean values (i.e. its domain is the booleans)&lt;/p&gt;

&lt;h2 id=&#34;appendix-a-source-code&#34;&gt;Appendix A: Source code&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;and&lt;/code&gt;:&lt;/p&gt;
simple.core=&gt; (source and)
(defmacro and
  &#34;Evaluates exprs one at a time, from left to right. If a form
  returns logical false (nil or false), and returns that value and
  doesn&#39;t evaluate any of the other expressions, otherwise it returns
  the value of the last expr. (and) returns true.&#34;
  {:added &#34;1.0&#34;}
  ([] true)
  ([x] x)
  ([x &amp; next]
   `(let [and# ~x]
      (if and# (and ~@next) and#))))

&lt;p&gt;&lt;code&gt;identity&lt;/code&gt;:&lt;/p&gt;
simple.core=&gt; (source identity)
(defn identity
  &#34;Returns its argument.&#34;
  {:added &#34;1.0&#34;
   :static true}
  [x] x)

&lt;p&gt;&lt;code&gt;every&lt;/code&gt;:&lt;/p&gt;
simple.core=&gt; (source every?)
(defn every?
  &#34;Returns true if (pred x) is logical true for every x in coll, else
  false.&#34;
  {:tag Boolean
   :added &#34;1.0&#34;
   :static true}
  [pred coll]
  (cond
   (nil? (seq coll)) true
   (pred (first coll)) (recur pred (next coll))
   :else false))

&lt;p&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;:&lt;/p&gt;
simple.core=&gt; (source -&gt;)
(defmacro -&gt;
  &#34;Threads the expr through the forms. Inserts x as the
  second item in the first form, making a list of it if it is not a
  list already. If there are more forms, inserts the first form as the
  second item in second form, etc.&#34;
  {:added &#34;1.0&#34;}
  [x &amp; forms]
  (loop [x x, forms forms]
    (if forms
      (let [form (first forms)
            threaded (if (seq? form)
                       (with-meta `(~(first form) ~x ~@(next form)) (meta form))
                       (list form x))]
        (recur threaded (next forms)))
      x)))
</description>
    </item>
    
  </channel>
</rss>