<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welc on The long way through Software Craftsmanship</title>
    <link>https://alvarogarcia7.github.io/categories/welc/</link>
    <description>Recent content in Welc on The long way through Software Craftsmanship</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Apr 2015 22:09:54 +0000</lastBuildDate>
    <atom:link href="https://alvarogarcia7.github.io/categories/welc/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>What legacy code is about</title>
      <link>https://alvarogarcia7.github.io/blog/2015/04/21/what-legacy-code-is-about/</link>
      <pubDate>Tue, 21 Apr 2015 22:09:54 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2015/04/21/what-legacy-code-is-about/</guid>
      <description>&lt;p&gt;In his book &lt;a href=&#34;http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/ref=sr_1_1?ie=UTF8&amp;amp;qid=1429647115&amp;amp;sr=8-1&amp;amp;keywords=legacy+code+feathers&#34; target=&#34;_blank&#34;&gt;Working effectively with legacy code&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/mfeathers&#34; target=&#34;_blank&#34;&gt;Michael Feathers&lt;/a&gt; describes:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[&amp;hellip;] legacy code as code without tests. It is a good working definition, and it points to a solution [&amp;hellip;]&lt;/p&gt;

&lt;p&gt;M Feathers, in the preface of Working effectively with legacy code&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I really like this definition. It is objective and measurable. But this is also a downside. Let&amp;rsquo;s take any concurrent code, for example: you can achieve 100% coverage on a single thread and the program could have defects when executed in parallel. But this might be an outlier, as concurrency is difficult to test. Let&amp;rsquo;s take another example.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s a imagine a non-concurrent (i.e., single thread) code composed by a single class (no collaborators; just one responsibility; it is &amp;ldquo;Clean Code&amp;rdquo;, as defined per R.C. Martin&amp;rsquo;s book) that has some happy paths as well as some error-handling cases. As usual. The original code writer has decided to test only the happy paths. They deployed it to production, as the product was ready. You inherit this code.&lt;/p&gt;

&lt;p&gt;After the system is deployed to production, you start receiving defect reports on the happy paths (the tested part). The first one, you cross it off as an one-time thing. Then the second and third come. You take a deeper look and start seeing some inconsistencies in the tests, some tests that actually do not test anything interesting:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;some test the test framework&lt;/li&gt;
&lt;li&gt;some the language&lt;/li&gt;
&lt;li&gt;some test a happy path that works by pure luck&lt;/li&gt;
&lt;li&gt;some functionalities are tested (not all happy paths)&lt;/li&gt;
&lt;li&gt;there&amp;rsquo;s actually a defect converted into a specification (test) (??)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now, I ask myself this question: when did I start considering this code as legacy? When I saw the bug reports in production (several in a row) or when I saw the poor suite of tests?&lt;/p&gt;

&lt;p&gt;I do think this codebase is legacy, no matter when I realized about it. But my first instinct would be to consider it legacy from the moment I received the bug reports, as I lost the trust in that code.&lt;/p&gt;

&lt;p&gt;Because for me, &lt;strong&gt;legacy code is about trust, not tests&lt;/strong&gt;. You can have tests but no trust; you can have trust but no tests (the latter is more difficult in non-trivial codebases.)&lt;/p&gt;

&lt;p&gt;This is why I would like to update the definition:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Legacy code is code without tests that provide trust to all your stakeholders&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The last part is very important, because the definition is no longer objective but depends from person to person. If the codebase doesn&amp;rsquo;t have tests, it is definitely legacy. But even if it has them, would you consider the given example a legacy or non-legacy code?&lt;/p&gt;

&lt;p&gt;These stakeholders include everyone affected or affecting the product: owners, developer team (in the scrum, wide sense), users, clients, &amp;hellip;&lt;/p&gt;

&lt;p&gt;Full disclosure: I&amp;rsquo;ve written plenty of legacy code. Code which I thought was good but really wasn&amp;rsquo;t. Even with tests, even with TDD, even with Clean Code. This has made me change my mind about what legacy code is all about.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>