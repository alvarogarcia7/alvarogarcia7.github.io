<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>The long way through Software Craftsmanship</title>
    <link>https://alvarogarcia7.github.io/categories/log/index.xml</link>
    <description>Recent content on The long way through Software Craftsmanship</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://alvarogarcia7.github.io/categories/log/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Self-Study in July 2017</title>
      <link>https://alvarogarcia7.github.io/blog/2017/07/01/self-study-july-2017/</link>
      <pubDate>Sat, 01 Jul 2017 10:32:19 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2017/07/01/self-study-july-2017/</guid>
      <description>

&lt;h2 id=&#34;a-brief-history-of-the-uuid-https-segment-com-blog-a-brief-history-of-the-uuid&#34;&gt;&lt;a href=&#34;https://segment.com/blog/a-brief-history-of-the-uuid/&#34; target=&#34;_blank&#34;&gt;A Brief History of the UUID&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read this article by Rick Branson on the history of UUID.
Describes the history of uid, uuid, early computing (both networked and not networked) and their own implementation of a uuid library&lt;/p&gt;

&lt;p&gt;Tags: uuid, uid, flake, snowflake, ksuid, go, golang, rick-branson, library, implementation-history&lt;/p&gt;

&lt;h2 id=&#34;more-data-more-data-https-blog-cloudflare-com-more-data-more-data&#34;&gt;&lt;a href=&#34;https://blog.cloudflare.com/more-data-more-data/&#34; target=&#34;_blank&#34;&gt;More data, more data&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read this article about how cloudflare manages its logs. By Hunter Blanks&lt;/p&gt;

&lt;p&gt;Tags: log, cloudflare, comparison, what-worked, what-did-not-work, kafka, citusdb, sre, site-reliability-engineering, analytics, hunter-blanks&lt;/p&gt;

&lt;h2 id=&#34;help-your-team-stop-overcommitting-by-empowering-them-to-say-no-https-hbr-org-2017-06-help-your-team-stop-overcommitting-by-empowering-them-to-say-no&#34;&gt;&lt;a href=&#34;https://hbr.org/2017/06/help-your-team-stop-overcommitting-by-empowering-them-to-say-no&#34; target=&#34;_blank&#34;&gt;Help Your Team Stop Overcommitting by Empowering Them to Say No&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read this article that describes how important is to say no to some ideas or projects so you can say yes to others.
In other words, how prioritizing is important as time and energy (i.e., resources) are not infinite and must be allocated accordingly&lt;/p&gt;

&lt;p&gt;Tags: diana-kander, hbr, harvard-business-review, priority, energy, resources, time, pet-project, yes-people, no-people, yes-culture, no-culture&lt;/p&gt;

&lt;h2 id=&#34;not-even-wrong-ways-to-dismiss-technology-http-ben-evans-com-benedictevans-2017-5-24-not-even-wrong-ways-to-dismiss-technology&#34;&gt;&lt;a href=&#34;http://ben-evans.com/benedictevans/2017/5/24/not-even-wrong-ways-to-dismiss-technology&#34; target=&#34;_blank&#34;&gt;Not even wrong - ways to dismiss technology&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read this article about how technology can be seen as toys before it is developed to the point where it can be expanded and used for other purposes than the one expected / designed for. By Benedict Evans.&lt;/p&gt;

&lt;p&gt;Tags: benedict-evans, technology, prediction, usage, invention, philosophy, wolfgang-pauli&lt;/p&gt;

&lt;h2 id=&#34;do-we-have-a-better-option-here-https-softwaremill-com-do-we-have-better-option-here&#34;&gt;&lt;a href=&#34;https://softwaremill.com/do-we-have-better-option-here/&#34; target=&#34;_blank&#34;&gt;Do we have a better Option here?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read this article comparing &lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Optional&lt;/code&gt; as types that can contain a value, but maybe not. By Micha≈Ç Chmielarz&lt;/p&gt;

&lt;p&gt;Tags: michal-chmielarz, option, optional, vavr, javaslang, comparison&lt;/p&gt;

&lt;h2 id=&#34;is-the-keyboard-faster-than-the-mouse-http-danluu-com-keyboard-v-mouse&#34;&gt;&lt;a href=&#34;http://danluu.com/keyboard-v-mouse/&#34; target=&#34;_blank&#34;&gt;Is the keyboard faster than the mouse?&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read this article by Dan Luu comparing the use of the mouse and the use of the keyboard and their speeds.
He groups existing literature on the topic plus some experiments he has done himself.&lt;/p&gt;

&lt;p&gt;Mentions the amount of myths related to this, based on old and non-accurate research.&lt;/p&gt;

&lt;p&gt;Tags: dan-luu, keyboard, comparison, mouse, human-interaction-device, hid, interaction, user-experience, interface&lt;/p&gt;

&lt;h2 id=&#34;the-crypto-anarchist-manifesto-http-groups-csail-mit-edu-mac-classes-6-805-articles-crypto-cypherpunks-may-crypto-manifesto-html&#34;&gt;&lt;a href=&#34;http://groups.csail.mit.edu/mac/classes/6.805/articles/crypto/cypherpunks/may-crypto-manifesto.html&#34; target=&#34;_blank&#34;&gt;The Crypto Anarchist Manifesto&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve read this article by Timothy C. May forecasting the development of a new market based on cryptography and secure communications.&lt;/p&gt;

&lt;p&gt;The same that barbed wire transformed property in the West, is the analogy he uses&lt;/p&gt;

&lt;p&gt;Tags: timothy-may, anarchy, encryption, market, forecast, crypto-anarchism, public-key-encryption, zero-knowledge-proof, cryptography&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Logging is a feature</title>
      <link>https://alvarogarcia7.github.io/blog/2015/04/19/logging-is-a-feature/</link>
      <pubDate>Sun, 19 Apr 2015 23:43:10 +0000</pubDate>
      
      <guid>https://alvarogarcia7.github.io/blog/2015/04/19/logging-is-a-feature/</guid>
      <description>&lt;p&gt;At a client, we&amp;rsquo;re facing this challenge: we cannot access production logs, as we don&amp;rsquo;t have access to production environments. The solution we&amp;rsquo;ve chose is to implement the logging component as a layer on top of &lt;a href=&#34;http://www.splunk.com/&#34; target=&#34;_blank&#34;&gt;Splunk&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This formatter layer &amp;ndash;per component&amp;ndash; accesses a generic layer &amp;ndash;for the whole company&amp;ndash; that accesses splunk. In this manner, it is very easy to reuse the splunk connection and configuration and inject mocks. Also helps with the local environment: you always log to console (even if in production you don&amp;rsquo;t have access to it) and can disable this in local, not needing a local splunk installation.&lt;/p&gt;

&lt;p&gt;Strategies for dealing with this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;functional logger: no shared state

&lt;ul&gt;
&lt;li&gt;can only log information available in this scope: parameters, attributes, static information&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;stateful logger: information is added to the threadContext and logged whenever necessary

&lt;ul&gt;
&lt;li&gt;can log information in this scope plus any of the previous invokings.&lt;/li&gt;
&lt;li&gt;the problem is precisely sharing state: you have to control all the possible parents to know where this data comes from. A piece of information may come from any source.&lt;/li&gt;
&lt;li&gt;Lose the reference of who is invoking you, as there is no customization for this. (only using implementation)&lt;/li&gt;
&lt;li&gt;Speak two different languages: one for logging and one for business logic&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;mixed: mix and match the best of both worlds.

&lt;ul&gt;
&lt;li&gt;The problem with the shared state can be solved if no data is overwritten and any information is stored in a map where the key is the fully qualified (FQ) method name (or FQ class name + FQ method name)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The GOOS book explains this very well on the 20th chapter, first half &amp;ldquo;logging is a feature&amp;rdquo;. If we log as described in chapters 19 and 20, some of the problems are reduced:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;multiple levels of abstraction&lt;/li&gt;
&lt;li&gt;indirect control over logging. decide in a single place whether to log exceptions of each kind or not&lt;/li&gt;
&lt;li&gt;remove &amp;ldquo;implementation details&amp;rdquo; such as &amp;ldquo;log.isDebugEnabled&amp;rdquo;&lt;/li&gt;
&lt;li&gt;remove performance issues: no need to build strings for logging every time, only need to pass objects. inside the logging layer, if the logger is enabled for that level, then spend the time building strings and print them
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We should remember that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Whenever logging becomes useful data (for the stakeholders) it no longer is a debug information and needs to be tested (automatically). In my opinion, it is not enough to test it daily when debugging, as these stakeholders rely on the data. Also, humans are not good detecting small differences, while machines excel at it.&lt;/li&gt;
&lt;li&gt;Why treat the logging feature different from any other? It is an investment, like any other, and as such should work properly&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>