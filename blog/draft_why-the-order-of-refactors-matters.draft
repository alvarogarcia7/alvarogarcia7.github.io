---
published: false
categories:
  - sample
  - refactoring
  - theory
  - big-o-notation
  - refactor
  - cost
---

TODO expand this post

the result of the refactoring is the same, the cost isn't

Levels of automatic refactoring:

  * No automation, whatsoever
  * Search and replace, no automatic refactor
  * Simple refactor: rename, extract method, ...
  * Complex refactor: extract method object, pull up interface, replace inheritance with polymorphism, ...

Levels of navigation:

  * No automation, whatsoever
  * Search in file
  * Search global
  * Go to definition by string match
  * Go to definition by fully qualified class name (FQCN)
  * Go to definition by fully qualified class name (FQCN) and parameters (to support overload). Might not work in dynamicly typed languages

The cost of writing / adapting tests is not included, as this has to be done either way (manual or automatic)

There are some languages / editors that might prevent refactoring as they don't make it easy

TODO continue with this example:


original: 
int sum = double(abs(1 + 1));

what I want:
int sum = doubleAbs(1+1);

how to get there:

  * extract method (no parameters)
  * introduce parameter


  * extract variable
  * extract method (one parameter)


result:
int sum = doubleAbs(1+1);

int doubleAbs(int value) {
	return double(abs(value));
}

---

imagine the code as a graph:

at the initial point in time (t0, might be the current one), at each modification of the code, the code travels from a vertex to another.

in each edge there is the name of the refactor and its cost.

in each vertex there is the state (either current or future)

it is clear that the graph has cycles, so it cannot be a tree but a general graph. it is also weighted as each refactor has an associated weight.

there must be cycles, as:

  * two refactors (a, b) might  be commutative (A = a · b = b · a). example, a = replace type code with subclass, b = replace constructor with factory method. A = you end up with subclasses, generated by a factory / abstract factory.
  * the refactor (A) might be decomposable in smaller refactors (a,b), a · b = A. This might be a smell that the first refactor was not complete or not correctly finished. example, A = introduce explanatory variable -> block b to variable y; a = introduce explanatory variable -> block b to variable x, b = rename x to y
  * two refactors might cancel each other: a · b · x = x. a · b = identity. example, a: extract explanatory method, b: inline method

following the refactoring algorithm, it is not possible to navigate the graph in an infinite path, as each refactor should decrease the cost of future modifications and its simplicity >>>

according to the definition, .....????

> a change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior

therefore, I'm not so sure if the graph has cycles or not. If it doesn't have cycles, as it originates from the sourcecode in one point in time, it is guaranteed to be a tree, as all nodes are connected (originating from the source)


----

20151229-124956 AGB

There are things that affect structure (e.g., extract) and others affect internals (e.g., rename). This is from an object POV.

further ideas: 

  * chain / unchain
  * split / join

