---
published: false
categories:
  - sample
  - ideas
---

* post on apitools: 
  * https://twitter.com/romainhuet/status/572486794723393536
  * https://twitter.com/apitools
* What sound dies a code that is not being tested?
  * I only care for the observable behaviour, not the rest
  * All my behaviors should be tested. What is not tested is lost
  * The tests should be automatic as I want to execute them quite often
* my TDD + GTD setup
  * tags: GTD and TDD; add a link to Connor mendenhall
  * also connected to the idea of scratchpad.md; IIRC there was a blogpost about this already
* Software as a means to an end
* What motivates a developer: autonomy, mastery, purpose
  * http://jaxenter.com/motivates-developers-hint-probably-money-113347.html
* 2015-06-25
  * however, it is delivered on time but doesnâ€™t fulfill the actual need, the specification must have been wrong, so the customer gets the blame - POODR, page 9 (sheet 34)
  * Idea that: if we break the "time" leg, it's the programmers; if we break the "scope" leg, it's the client


* There are more ideas in the TODO task management tool
* Inheritance and polymorphism
  * In OO we're taught they go hand in hand
  * In functional languages, you can have polymorphism without inheritance.
    * map, filter, ... work on sequences, vector, sets
	* add example of polymorphism without inheritance in java, simulating duck typing
  * you can have inheritance without polymorphism
    * maybe the main use of this is to statically type objects. but why do you want to specify types if the behavior is the same?
	* maybe this should not be done, as what you want is behavior, not types
  * Take a look at clojurescript-unraveled, section 3.10
* Brown-bag session on SaaS, by our SaaS architect
* Idea that solutions & products are the same as developers and operations and the devOps movement should also apply to both.
  * In a sufficiently modular software, any client-specific solution should be capable to be injected in the general product. 
  * Write example about this
* Write how to generate lazy generators in java or other non-lazy languages
  * Include code to generate Range (already implemented in java)
  * Compare with another utility library (e.g., Apache commons)
  * Compare with the Haskell and Clojure source
  * Compare with the yield keyword in python
* Add post on transducers and the clojure article (funcool.github.io/clojurescript-unraveled)
* Jitpack.io for sharing dependencies, just like spring boot


20150907-140403 AGB

  * In the unix command-line, some  of the same patterns apply as in functional programming with a REPL: hacked code / programming by coincidence, as there is not a previous design (or even a thought). The function names are not well chosen as it is "easy" to see what they do.
    * Any other similities or differences?

2015-11-25-12:04 AGB

  * the double objective when teaching: yours and your student's
  * the difference of deliberate practice and deliberate use 

2016-04-27-1413 AGB

a new kind of kata. the code is so clean, separated that reaches the overengineering level. the kata starts with that code and the purpose is to remove the overengineering. each pair will stop at a given point. the important part is the discussion between all the pairs, afterwards.
  
  another variation would be: from legacy reach a clean state, from overengineered reach a clean state. compare both paths: cost, easiness, ways of working, pleasantness, etc


2017-02-27 1132 AGB

The discussion of composition vs inheritance for console commands
  - by chris j,
  - reference to the clojure bot, that serves as a platform
  - combinatorial explosion of commands when inheriting
  - power to compose commands when composition
  - example: find-infra folders, then list/check/update -> ...


