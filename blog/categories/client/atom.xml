<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Client | The long way through Software Craftsmanship]]></title>
  <link href="http://alvarogarcia7.github.io/blog/categories/client/atom.xml" rel="self"/>
  <link href="http://alvarogarcia7.github.io/"/>
  <updated>2015-08-03T01:47:33+02:00</updated>
  <id>http://alvarogarcia7.github.io/</id>
  <author>
    <name><![CDATA[alvaro garcia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploring Testing With Java 8 Lambdas]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/30/exploring-testing-with-java-8-lambdas/"/>
    <updated>2015-07-30T13:04:10+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/30/exploring-testing-with-java-8-lambdas</id>
    <content type="html"><![CDATA[<p>At a client, we were testing a simple feature, but the resulting tests had much subtle repetition:</p>

<p>(source code is <a href="https://github.com/alvarogarcia7/spike-lambda-testing/tree/ef00a220f427900e3180dcbeec51248845446248">here</a>)</p>

<pre><code class="java">@Test
public void log_when_sending_greeting_letters() {

    sut.send(mock(GreetingLetter.class));

    verify(logger).sentGreetingLetter();
}

@Test
public void log_when_sending_love_letters() {

    sut.send(mock(LoveLetter.class));

    verify(logger).sentLoveLetter();
}
</code></pre>

<p>and the production code:</p>

<pre><code class="java">public class MailSender {
    private final EventLogger eventLogger;

    public MailSender (final EventLogger eventLogger) {
        this.eventLogger = eventLogger;
    }

    public void send (final GreetingLetter letter) {
        // more business logic
        eventLogger.sentGreetingLetter();
    }

    public void send (final LoveLetter letter) {
        // more business logic
        eventLogger.sentLoveLetter();
    }
}
</code></pre>

<p>Note: this is an adapted code, so the business logic is not complete and seems simple.</p>

<p>So I decided to explore a bit on refactoring these tests to use lambdas and reduce repetition:</p>

<pre><code class="java">private MailSender sut;
private Consumer&lt;MailSender&gt; arrange;
private Consumer&lt;EventLogger&gt; verify;

@Test
public void log_greetings_letter() {
    arrange = (MailSender sut) -&gt; sut.send(mock(GreetingLetter.class));

    verify = EventLogger::sentGreetingLetter;

    assertAndVerify();
}

@Test
public void log_love_letter() {
    arrange = (MailSender sut) -&gt; sut.send(mock(LoveLetter.class));

    verify = EventLogger::sentLoveLetter;

    assertAndVerify();
}

private void assertAndVerify() {
    arrange.accept(sut);
    verify.accept(logger);
}
</code></pre>

<p>Some comments, mine and my teammates:</p>

<ul>
<li>The tests are not very readable, maybe because we&rsquo;re still not used to java 8 lambdas</li>
<li><code>assertAndVerify</code> has multiple purposes / responsibilities</li>
<li>The gain of usability does not outweight the loss of readability</li>
</ul>


<p>Finally, the refactor was discarded and we are using the initial version.</p>

<p>Later, in the dojo, <a href="https://twitter.com/@trikitrok">Manuel</a> and I have refactored this a little bit more. Source code is <a href="https://github.com/alvarogarcia7/spike-lambda-testing/tree/8e3dbecd91e1ead33c5b3f6560e2a786c36b0de9">here</a></p>

<pre><code class="java">public class MailSenderShould {

    private EventLogger eventLogger;
    private MailSender mailSender;

    @Before
    public void setUp () {
        eventLogger = mock(EventLogger.class);
        mailSender = new MailSender(eventLogger);
    }

    @Test
    public void log_greetings_letter() {
        checkThat(aLoggingLine().forA(greetingLetter()).wasLoggedWhen(aGreetingLetterWasSent()));
    }

    @Test
    public void log_love_letter() {
        checkThat(aLoggingLine().forA(loveLetter()).wasLoggedWhen(aLoveLetterWasSent()));
    }

    private void checkThat (final Check check) {
        check.checkFor(mailSender, eventLogger);
    }

    private Consumer&lt;EventLogger&gt; aGreetingLetterWasSent () {
        return EventLogger::sentGreetingLetter;
    }

    private Consumer&lt;MailSender&gt; greetingLetter () {
        return (MailSender sut) -&gt; sut.sendGreetingLetter(mock(GreetingLetter.class));
    }

    private Consumer&lt;MailSender&gt; loveLetter () {
        return (MailSender sut) -&gt; sut.sendLoveLetter(mock(LoveLetter.class));
    }

    private Consumer&lt;EventLogger&gt; aLoveLetterWasSent () {
        return EventLogger::sentLoveLetter;
    }
}
</code></pre>

<p>(the logger is <a href="https://github.com/alvarogarcia7/spike-lambda-testing/blob/8e3dbecd91e1ead33c5b3f6560e2a786c36b0de9/src/test/java/com/example/lambdatesting/CheckBuilder.java">here</a>)</p>

<p>Later, we have created a simpler functional DSL for the logging, joining the <code>act</code> and <code>verify</code> into an object called <code>Check</code></p>

<pre><code class="java">public class MailSenderShould {

    private EventLogger eventLogger;
    private MailSender mailSender;

    @Before
    public void setUp () {
        eventLogger = mock(EventLogger.class);
        mailSender = new MailSender(eventLogger);
    }

    @Test
    public void log_greetings_letter() {
        mailSenderLogs(whenSendingAGreetingLetter());
    }

    @Test
    public void log_love_letter() {
        mailSenderLogs(whenSendingALoveLetter());
    }

    private Check whenSendingALoveLetter () {
        return new Check(
            (MailSender sut) -&gt; sut.send(letter(LoveLetter.class)),
            EventLogger::sentLoveLetter
        );
    }

    private void mailSenderLogs (Check check) {
        check.checkFor(mailSender, eventLogger);
    }

    private Check whenSendingAGreetingLetter () {
        return new Check(
            (MailSender sut) -&gt; sut.send(letter(GreetingLetter.class)),
            EventLogger::sentGreetingLetter
        );
    }

    private &lt;T&gt; T letter (final Class&lt;T&gt; typeOfLetter) {
        return mock(typeOfLetter);
    }
}
</code></pre>

<p>and the <code>Check</code>, just a placeholder for two <code>Consumer</code>s:</p>

<pre><code class="java">public class Check {

    private final Consumer&lt;MailSender&gt; act;
    private final Consumer&lt;EventLogger&gt; verify;

    public Check (final Consumer&lt;MailSender&gt; act, final Consumer&lt;EventLogger&gt; verify) {
        this.act = act;
        this.verify = verify;
    }

    public void checkFor(MailSender mailSender, EventLogger eventLogger) {
        act.accept(mailSender);
        verify.accept(eventLogger);
    }
}
</code></pre>

<h2>Comparison</h2>

<p>Comparison between the original form and the three refactored forms of the test:</p>

<pre><code class="java">@Test
public void log_when_sending_greeting_letters() {

    sut.send(mock(GreetingLetter.class));

    verify(logger).sentGreetingLetter();
}
</code></pre>

<p>This reads like a classical JUnit tests, using the interaction (with mocks).</p>

<pre><code class="java">@Test
public void log_greetings_letter() {
    arrange = (MailSender sut) -&gt; sut.send(mock(GreetingLetter.class));

    verify = EventLogger::sentGreetingLetter;

    assertAndVerify();
}
</code></pre>

<p>This is the first step towards more cohesion, at the cost of readability. You save the verify at the end, but the repeated method <code>assertAndVerify</code> is still present.</p>

<pre><code class="java">@Test
public void log_greetings_letter() {
    checkThat(aLoggingLine().forA(greetingLetter()).wasLoggedWhen(aGreetingLetterWasSent()));
}
</code></pre>

<p>This one reads more like a classical DSL, but is harder to read compared to a classical test.</p>

<pre><code class="java">@Test
public void log_greetings_letter() {
    mailSenderLogs(whenSendingAGreetingLetter());
}
</code></pre>

<p>This one reads more like a business requirement.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Brown-bag Session: Refactoring Legacy Code]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/01/brownbag-session-refactoring-legacy-code/"/>
    <updated>2015-07-01T13:18:28+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/01/brownbag-session-refactoring-legacy-code</id>
    <content type="html"><![CDATA[<p>Today I have done a brown bag session about refactoring legacy code. It includes:</p>

<ul>
<li>legacy code definition. There is no agreement about this in the team.</li>
<li>the legacy code change algorithm (source is Feathers, Working effectively with legacy code). Plus an example about it.</li>
<li>working with legacy code</li>
<li>experience with it.</li>
</ul>


<p>The slides are available <a href="../../../../uploads/refactoring-legacy-code-slides.pdf">here</a> (PDF format)</p>

<p>We also did a practical session, whose experience report is <a href="../../../../2015/06/23/brown-bag-session-refactoring-legacy-code/">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Brown-bag Session: Refactoring Legacy Code]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/06/23/brown-bag-session-refactoring-legacy-code/"/>
    <updated>2015-06-23T19:19:28+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/06/23/brown-bag-session-refactoring-legacy-code</id>
    <content type="html"><![CDATA[<p>Today I have facilitated a brown bag session about refactoring legacy code applications, as this is the case with one of the applications we maintain and add new features to.</p>

<p>The contents of the session:</p>

<ul>
<li>Briefly exposing the problem to the team, me taking the role of the Product Owner (PO)</li>
<li>Ask the dev team to add an easy feature</li>
<li>Do it without tests, as it was so simple that they thought they could do it (using mob programming)</li>
<li>Ask if they were satisfied by the patch / fix. Answer was yes.</li>
<li>Point out that there are regressions in the few lines of the patch</li>
<li>Repeat the session, starting with adding tests to guarantee the behavior is preserved  (using mob programming)</li>
<li>Explain the technique of the golden master</li>
<li>Some more programming, until they start to see the light at the end of the tunnel</li>
<li>Small retrospective, including:

<ul>
<li>asking them their feelings when dealing with legacy code. The contents of this is pretty similar to the concepts that appear in the retrospectives, when talking about the legacy project / submodule.</li>
<li>what could I improve as facilitator or for the structure of the session</li>
</ul>
</li>
</ul>


<p>The repo can be found <a href="https://github.com/alvarogarcia7/trivia-kata-spike">here</a>.</p>

<p>I prepared a small script:</p>

<pre><code class="bash">while test true; do
  git add --all;
  git commit --all -m "save process - uknown state";
  sleep 120;
done;
</code></pre>

<p>that saves the process and the progress, without disturbing the attendees. This allows you to follow the progress without any distraction. This idea was taken from a similar one from  <a href="http://twitter.com/@xav1uzz">Xavi Gost</a> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>This same idea was also cited by someone else, if I recall correctly by Sandro Mancuso, saying that it would be a good idea to have a background git repository while working. IntelliJ IDEA already does something similar (and saves the events, e.g., when the tests are run, either red or green)</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Cannot find the source, it was about having a script to commit automatically each time you run the tests; if it was red while refactoring, it would do git checkout (to revert); Was related to the noFlopSquad<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Brown-bag Session: Docker]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/06/16/brown-bag-session-docker/"/>
    <updated>2015-06-16T18:52:28+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/06/16/brown-bag-session-docker</id>
    <content type="html"><![CDATA[<p>Today we have done a brown bag session about Docker. One of the team members explained to us the latest news, topics and how tos, including:</p>

<ul>
<li>the difference between a container and an image</li>
<li>diffing image contents</li>
<li>AUFS (Another Union FS)</li>
<li>persistent vs non-persistent (volatile) filesystems</li>
<li>running CMD and other commands on the instance</li>
<li>problems of running with permission = root (or its group)</li>
<li>downsides of it</li>
<li>how to compare it with a virtual machine</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logging Is a Feature]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/04/19/logging-is-a-feature/"/>
    <updated>2015-04-19T23:43:10+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/04/19/logging-is-a-feature</id>
    <content type="html"><![CDATA[<p>At a client, we&rsquo;re facing this challenge: we cannot access production logs, as we don&rsquo;t have access to production environments. The solution we&rsquo;ve chose is to implement the logging component as a layer on top of <a href="http://www.splunk.com/">Splunk</a>.</p>

<p>This formatter layer &ndash;per component&ndash; accesses a generic layer &ndash;for the whole company&ndash; that accesses splunk. In this manner, it is very easy to reuse the splunk connection and configuration and inject mocks. Also helps with the local environment: you always log to console (even if in production you don&rsquo;t have access to it) and can disable this in local, not needing a local splunk installation.</p>

<p>Strategies for dealing with this:</p>

<ul>
<li>functional logger: no shared state

<ul>
<li>can only log information available in this scope: parameters, attributes, static information</li>
</ul>
</li>
<li>stateful logger: information is added to the threadContext and logged whenever necessary

<ul>
<li>can log information in this scope plus any of the previous invokings.</li>
<li>the problem is precisely sharing state: you have to control all the possible parents to know where this data comes from. A piece of information may come from any source.</li>
<li>Lose the reference of who is invoking you, as there is no customization for this. (only using implementation)</li>
<li>Speak two different languages: one for logging and one for business logic</li>
</ul>
</li>
<li>mixed: mix and match the best of both worlds.

<ul>
<li>The problem with the shared state can be solved if no data is overwritten and any information is stored in a map where the key is the fully qualified (FQ) method name (or FQ class name + FQ method name)</li>
</ul>
</li>
</ul>


<p>The GOOS book explains this very well on the 20th chapter, first half &ldquo;logging is a feature&rdquo;. If we log as described in chapters 19 and 20, some of the problems are reduced:</p>

<ul>
<li>multiple levels of abstraction</li>
<li>indirect control over logging. decide in a single place whether to log exceptions of each kind or not</li>
<li>remove &ldquo;implementation details&rdquo; such as &ldquo;log.isDebugEnabled&rdquo;</li>
<li>remove performance issues: no need to build strings for logging every time, only need to pass objects. inside the logging layer, if the logger is enabled for that level, then spend the time building strings and print them</li>
</ul>


<p>We should remember that:</p>

<ul>
<li>Whenever logging becomes useful data (for the stakeholders) it no longer is a debug information and needs to be tested (automatically). In my opinion, it is not enough to test it daily when debugging, as these stakeholders rely on the data. Also, humans are not good detecting small differences, while machines excel at it.</li>
<li>Why treat the logging feature different from any other? It is an investment, like any other, and as such should work properly</li>
</ul>

]]></content>
  </entry>
  
</feed>
