<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Quote | The long way through Software Craftsmanship]]></title>
  <link href="http://alvarogarcia7.github.io/blog/categories/quote/atom.xml" rel="self"/>
  <link href="http://alvarogarcia7.github.io/"/>
  <updated>2015-07-27T00:53:01+02:00</updated>
  <id>http://alvarogarcia7.github.io/</id>
  <author>
    <name><![CDATA[alvaro garcia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quote: Organizing Code to Allow for Easy Changes]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/08/quote-organizing-code-to-allow-for-easy-changes/"/>
    <updated>2015-07-08T02:41:54+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/08/quote-organizing-code-to-allow-for-easy-changes</id>
    <content type="html"><![CDATA[<h2>Organizing Code to Allow for Easy Changes</h2>

<blockquote><p>Asserting that code should be easy to change is akin to stating that children should be polite; the statement is impossible to disagree with yet it in no way helps a parent raise an agreeable child. The idea of easy is too broad; you need concrete definitions of easiness and specific criteria by which to judge code.
If you define easy to change as</p>

<ul>
<li>Changes have no unexpected side effects</li>
<li>Small changes in requirements require correspondingly small changes in code</li>
<li>Existing code is easy to reuse</li>
<li>The easiest way to make a change is to add code that in itself is easy to change</li>
</ul>


<p>Then the code you write should have the following qualities. Code should be:</p>

<ul>
<li><strong>Transparent</strong> The consequences of change should be obvious in the code that is changing and in distant code that relies upon it</li>
<li><strong>Reasonable</strong> The cost of any change should be proportional to the benefits the change achieves</li>
<li><strong>Usable</strong> Existing code should be usable in new and unexpected contexts</li>
<li><strong>Exemplary</strong> The code itself should encourage those who change it to perpetuate
these qualities</li>
</ul>


<p>Code that is Transparent, Reasonable, Usable, and Exemplary (TRUE) not only meets todayâ€™s needs but can also be changed to meet the needs of the future. The first step in creating code that is TRUE is to ensure that each class has a single, well-defined responsibility.</p>

<p>Practical Object Oriented Design in Ruby, by Sandi Metz</p></blockquote>

<p>This can be found the in POODR > Chapter 2. Designing Classes with a Single Responsibility > Organizing Code to Allow for Easy Changes</p>

<p>Note: Bold is mine</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Types of Defects]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/06/14/types-of-defects/"/>
    <updated>2015-06-14T16:16:51+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/06/14/types-of-defects</id>
    <content type="html"><![CDATA[<p>Some time ago, while researching types of defects and the cost of fixing them<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, I stumbled upon this:</p>

<blockquote><p>Years ago I worked with a bunch of economists in the US Federal Government - they categorized &lsquo;bugs&rsquo; in their memos into three types:</p>

<ul>
<li><p>Typos: Simple misspellings of words. Infrequent, easy to detect, easy to fix.</p></li>
<li><p>Writos: Incoherent sentences. More frequent, hard to detect, harder to fix.</p></li>
<li><p>Thinkos: Conceptually bonkers. Very frequent, subtle and hard to detect; almost impossible to fix.</p></li>
</ul>


<p>Most &lsquo;late&rsquo; bugs that I&rsquo;ve seen in software projects belong in the last category - a lack of design or the failure to make a working mock-up leads to &lsquo;thinkos&rsquo; which are only obvious when the application is nearly completed. These are expensive to fix.</p>

<p>Source: <a href="http://developers.slashdot.org/story/03/10/21/0141215/software-defects---do-late-bugs-really-cost-more">http://developers.slashdot.org/story/03/10/21/0141215/software-defects&#8212;do-late-bugs-really-cost-more</a></p></blockquote>

<p>I would also add a new category to this:</p>

<ul>
<li>Ethos: Morally wrong, although possibly legal. These may take different forms: vary from a company to the next one,
from society to society, etc. Even harder to fix than &lsquo;thinkos&rsquo;,
as there is a reason (mainly economic) to keep them in place.</li>
</ul>


<p>  On a technical note,
  these are not usually well-known artifacts in the company, therefore not everyone
  should know about them. Only a few developers know the correct reasons behind them and
  the rest might be sold a fake reason, so the latter cannot fix these &lsquo;ethos&rsquo;, as they
  assume they are present for a good reason</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>This is also a chapter in the book <a href="https://leanpub.com/leprechauns">The Leprechauns of Software Engineering</a> by Laurent Bossavit: &lsquo;Chapter 10: The cost of defects: an illustrated history&rsquo;<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Paper: TDD in Industrial Teams]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/05/12/paper-tdd-in-industrial-teams/"/>
    <updated>2015-05-12T00:02:44+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/05/12/paper-tdd-in-industrial-teams</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve read <a href="http://www.msr-waypoint.net/en-us/groups/ese/nagappan_tdd.pdf">this paper</a> by Nagappan, Maximilien, Bhat and Williams on the cost, advantages, pitfalls of doing TDD in industrial teams (private companies who create software).</p>

<h2>My notes</h2>

<p>Abstract:</p>

<blockquote><p>little empirical evidence supports or refutes the utility of this practice in an industrial context</p></blockquote>

<ul>
<li>they seem to be talking about inside-out tdd as in chapter 2 (page 291), they talk about small units and then integrating them in a bigger context</li>
</ul>


<h3>Benefits</h3>

<p>taken from chapter 2 (page 292)</p>

<ul>
<li>Better design</li>
<li>Efficiency</li>
<li>Test assets</li>
<li>Reducing defect injection</li>
</ul>


<h3>Conclusions</h3>

<blockquote><p>TDD seems to be applicable in various domains</p>

<p>[TDD] can significantly reduce the defect density of developed software without significant productivity reduction [&hellip;]</p>

<p>[&hellip;] an important aspect of TDD is the creation of tests assets.</p></blockquote>

<p>Recommendations (this is all quotes):</p>

<ul>
<li>Start TDD from the beginning of projects</li>
<li>For a team new to TDD, introduce automated build test integration towards the second third of the development phase</li>
<li>[&hellip;] add new tests every time a problem is found</li>
<li>Get the test team involved and knowledgeable about the TDD approach</li>
<li>Constantly running the unit tests [&hellip;]</li>
<li>Encourage fast unit test execution and efficient unit testing design</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Whose Fault Is This?]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/04/25/whose-fault-is-this/"/>
    <updated>2015-04-25T14:10:31+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/04/25/whose-fault-is-this</id>
    <content type="html"><![CDATA[<p>In the prologue of the book, while thanking everyone that has made the book possible:</p>

<blockquote><p>[&hellip;], none of the people mentioned here would be responsible for any inaccuracy that might exist in the book, as this responsibility is exclusively mine</p>

<p>Mihaly Csikszentmihalyi (translated)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>, prologue of &ldquo;<a href="http://www.amazon.com/Flow-The-Psychology-Optimal-Experience/dp/0061339202">Flow</a>&rdquo;</p></blockquote>

<p>(More posts on this same book, <a href="/blog/categories/flow">here</a>)</p>

<p>This connects with what <a href="http://twitter.com/@tastapod">Dan North</a> said in the Craft Conf about this idea of the &ldquo;I&rsquo;m the only one in the company producing good quality work, the rest are not doing the same&rdquo;. Of course, he was quoting greedy, selfish people who think this instead of attributing the success to the whole team.</p>

<p>Regarding the whole team, if I recall correctly, it was <a href="http://twitter.com/@svenpet">Sven Peters</a> who explained that &ldquo;[&hellip;] either the team wins or looses. There are no individual wins [&hellip;]&rdquo; <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></p>

<p>In this sense, Csikszentmihalyi assumes all responsibility when quoting and reflecting on other&rsquo;s works. It was his idea to develop on top of others, so any imperfection is his.</p>

<p>This is similar as when approving a pull request: you make sure that the code works and you stand by it. It is no longer the original owner&rsquo;s cause, but yours too, as you have signed this request. On the pull request, though, the code ownership is already distributed among the whole team, but approvals ensures the presence of the <a href="/blog/categories/guardian-of-the-source">guardian of the source</a></p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>I had to translate the quote, because I did not borrow the book in English<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>When the talks are available, we will be able the ensure the correct attribution of this idea.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Demand for TDD and Refactor]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/04/25/demand-for-tdd-and-refactor/"/>
    <updated>2015-04-25T13:28:20+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/04/25/demand-for-tdd-and-refactor</id>
    <content type="html"><![CDATA[<p>When I went to the Jason Gorman&rsquo;s TDD workshop (experience report <a href="../../../../2015/04/12/jason-gorman-tdd-intensive-workshop">here</a>), he said something interesting regarding refactor and TDD:</p>

<blockquote><p>In job offers / advertisements, TDD is much more in demand than refactor. But the latter is included in the former as an integral part.</p>

<p>Jason Gorman</p></blockquote>

<p>I agree with the second thought: you cannot properly do TDD without refactoring, as it is an integral part; also the third phase.</p>

<p>For me, sometimes refactoring is the difference between code and &ldquo;Clean Code&rdquo; (as defined in the book by the same title). If I cannot find the (algorithmic) pattern for the software I&rsquo;m writing, I try to introduce scaffolds to keep investigating until I can find a viable, general solution (if the problem requires it.)</p>

<p>Even after doing the refactor <code>replace algorithm</code>, the code might not have the responsibilities in the right place, the methods might be long, value objects not extracted yet, etc. This is where further refactor is needed to introduce all those qualities in the piece of software.</p>

<p>I believe that we programmers have done a bad job of communicating with the rest of the organization what refactoring is about. It has nothing to do with beauty, style or design (in the visual sense) but is related to maintainability, coupling, defects and quality. Money, in the long run, as its objective is to make it cheaper to change in the future, a better investment and ROI. This is the common language that the rest of the company understands.</p>
]]></content>
  </entry>
  
</feed>
