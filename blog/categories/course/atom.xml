<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Course | The long way through Software Craftsmanship]]></title>
  <link href="http://alvarogarcia7.github.io/blog/categories/course/atom.xml" rel="self"/>
  <link href="http://alvarogarcia7.github.io/"/>
  <updated>2015-07-13T08:06:06+02:00</updated>
  <id>http://alvarogarcia7.github.io/</id>
  <author>
    <name><![CDATA[alvaro garcia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Paper: Fundamental Concepts on Programming Languages]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/06/paper-fundamental-concepts-on-programming-languages/"/>
    <updated>2015-07-06T07:48:35+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/06/paper-fundamental-concepts-on-programming-languages</id>
    <content type="html"><![CDATA[<p>Note: all quotes on this post come from <a href="http://www.cs.cmu.edu/~crary/819-f09/Strachey67.pdf">this paper</a>: Strachey, C. Fundamental Concepts in Programming Languages. Published in Higher-Order and Symbolic Computation, 13, 11–49, 2000.</p>

<h2>Contents</h2>

<p>This paper starts slow, from the mathematical and philosophical point of view, until it gets to the basic concepts on the fundamental concepts:</p>

<ul>
<li>Assignment command</li>
<li>L-Value and R-Value</li>
<li>Definitions</li>
<li>Names</li>
<li>Numerals</li>
<li>Conceptual models: an explanation about the relationship between the code, the memory store and the abstract concepts</li>
</ul>


<p>Later, it gets more in depth to the conceptual constructs, where most of the content is explained and contains:</p>

<ul>
<li>Expressions and commands</li>
<li>Expressions and evaluations</li>
<li>Commands and sequencing</li>
<li>Definition of functions and routines</li>
<li>Functions and routines as data items</li>
<li>Types and polymorphism</li>
<li>Compound data structures</li>
</ul>


<p>Finally, as closing notes, it explains some implementation details (such as Load-Update Pairs), tools as Macrogenerators (nowadays called macros) and formal semantics</p>

<h2>Notes / highlights</h2>

<h3>L-Values and R-Values</h3>

<blockquote><p>L-value for the address-like object appropriate on the left of the assignment, and R-value for the contents-like object appropriate for the right</p>

<p>2.1, Assignment commands in page 14</p>

<p>An L-value represents an area of the store of the computer. [&hellip;] Two essential features [&hellip;] it has content &ndash;i.e., an associated R-value&ndash; and that it is in general possible to change this content</p>

<p>2.2, L-values and R-Values in pages 14-15</p></blockquote>

<h3>Referential transparency</h3>

<p>Explained in 3.2.1, Values:</p>

<blockquote><p>In essence, this means that if we wish to find the value of an expression with contains a sub-expression, the only thing we need to know about the sub-expression is its value.</p></blockquote>

<p>Also cites Quine <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> on this matter.</p>

<blockquote><p>We tend to assume automatically that the symbol <code>x</code> in an expression such as <code>3x**2 + 2x + 17</code> stands for the same thing (or has the same value) on each occasion it occurs. This is the most important consequence of referential transparency</p>

<p>3.3.1 Variables, page 22</p>

<p>If we consider L-values as well as R-Values, however, we can preserve referential transparency as far as L-values are concerned. Thi is because L-values, being generalised addresses, are not altered by assignment command</p>

<p>3.3.1 Variables, page 22</p></blockquote>

<h3>Types of variables: bound, free</h3>

<p>Explains the types of variables, based on their belonging to an environment or not: bound variable and free variable. Page 20</p>

<h3>Evaluating vs applying</h3>

<blockquote><p>Distinction between evaluating an operator and applying it to its operands
3.2.4, Evaluation, page 20</p></blockquote>

<p>This also introduces the concept of currification / currying:</p>

<blockquote><p>[&hellip;] for reducing operators with several operands to the successive application of single operands operators
3.2.4, Evaluation, page 21</p></blockquote>

<p>An example is given.</p>

<h3>Conditional expressions vs conditional commands</h3>

<p>Introduces the concept of conditional expression, akin to the ternary operator (example in java):</p>

<pre><code class="java">y = x &gt; 1 ? 1 : 2;
</code></pre>

<p>this is equivalent to (example in java):</p>

<pre><code class="java">int y;
if(x &gt; 1) {
    y = 1;
} else {
    y = 2;
}
</code></pre>

<p>and the conditional command (example in java):
<code>java
if (x &gt; 1) {
    f();
    h(x);
} else {
    g();
}
</code></p>

<p>The conditional expression is also known as &ldquo;functional if&rdquo;</p>

<h2>Parameter calling modes</h2>

<p>Explains call by value and call by reference, equivalent to calling by R-Value or L-Value, respectively</p>

<p>3.4.2, Parameter calling mode</p>

<h3>Functions and routines</h3>

<blockquote><p>Functions and routines are as different in their nature as expressions and commands. It
is unfortunate, therefore, that most programming languages manage to confuse them very
successfully</p>

<p>3.4.5 Functions and routines, page 30</p>

<p>The problem arises because we naturally expect referential transparency of R-values in
expressions, particularly those on the right of assignment commands</p>

<p>3.4.5 Functions and routines, page 30</p>

<p>Any departure of R-value referential transparency in a R-value context should
either be eliminated by decomposing the expression into several commands and simpler
expressions, or, if this turns out to be difficult, the subject of a comment</p>

<p>3.4.5 Functions and routines, page 30</p></blockquote>

<h3>Constancy and fixity</h3>

<p>&ldquo;Protection by freezing&rdquo;</p>

<blockquote><p>Constancy is thus an attribute of an L-value, and
is, moreover, an invariant attribute. Thus when we create a new L-value, and in particular
when we define a new quantity, we must decide whether it is a constant or a variable.</p>

<p>3.4.6 Constants and variables, page 30</p>

<p>[&hellip;] fixed function. This is defined as a function which
either has no free variables, or if it has, whose free variables are all both constant and fixed.</p>

<p>3.4.7, Fixed and free, page 31</p>

<p>Note that fixity is a property of the λ-expression&ndash;i.e., a property of the R-value, while
constancy is a property of the L-value.</p>

<p>3.4.7, Fixed and free, page 31</p></blockquote>

<p>In general:</p>

<ul>
<li>Constancy is an attribute of the L-Value</li>
<li>Fixity is an attribute of the R-Value</li>
</ul>


<p>Both for functions and objects.</p>

<h3>First and second class objects</h3>

<blockquote><p>A procedure, on the other hand, may only appear in another procedure call either
as the operator (the most common case) or as one of the actual parameters. There are no
other expressions involving procedures or whose results are procedures. Thus in a sense
procedures in ALGOL are second class citizens—they always have to appear in person
and can never be represented by a variable or expression</p>

<p>3.5.1, First and second class objects, page 32</p>

<p>Historically this second class status of procedures in ALGOL is probably a consequence
of the view of functions taken by many mathematicians: that they are constants whose
name one can always recognise.</p>

<p>3.5.1, First and second class objects, page 33</p>

<p>[&hellip;] it is remarkably difficult to stop looking on functions as second class objects</p>

<p>3.5.1, First and second class objects, page 33</p>

<p>and in particular, of functions which have functions as a result</p>

<p>3.5.1, First and second class objects, page 33</p></blockquote>

<h3>Closure</h3>

<blockquote><p>Thus the R-value of a function contains two parts—a rule for evaluating the expression,
and an environment which supplies its free variables. An R-value of this sort will be called
a closure.</p>

<p>3.5.2, Representation of functions, page 34</p></blockquote>

<h3>Types</h3>

<p>There is information on types: latent vs manifest, how to determine it</p>

<blockquote><p>We call attributes which can be determined at compile time in this way manifest; attributes
that can only be determined by running the program are known as latent</p>

<p>3.6.2, Manifest and latent, page 36</p></blockquote>

<h3>Polymorphism</h3>

<p>Ad-hoc vs parametric polymorphism</p>

<blockquote><p>In ad hoc polymorphism there is no single systematic way of determining the type of the
result from the type of the arguments. There may be several rules of limited extent which
reduce the number of cases, but these are themselves ad hoc both in scope and content</p>

<p>3.6.4, Polymorphism, page 37</p>

<p>Parametric polymorphism:</p>

<p>(α ⇒ β, α list) ⇒ β list</p>

<p>3.6.4, Polymorphism, page 37</p></blockquote>

<h3>Collections</h3>

<blockquote><ul>
<li><strong>List</strong>: An ordered sequence of objects all of the same type. The number is dynamically variable.</li>
<li><strong>Ntuple</strong>: An ordered sequence of objects all of the same type. The number is dynamically variable.</li>
<li><strong>Set</strong>: An ordered sequence of objects all of the same type. The number is dynamically variable.</li>
<li><strong>Bag or Coll</strong>: It consists of an unordered collection of objects all of which are of the same type and differs from a set in that repetitions are allowed</li>
</ul>


<p>3.7.7, Other forms of structure, page 45</p></blockquote>

<p>Also talks about &ldquo;rings&rdquo; (3.7.7, Other forms of structure, page 45)</p>

<h3>Macros</h3>

<blockquote><p>macrogenerators deal with the symbols which represent
the variables, values and other objects of concern to a program so that all their manipulation
is performed before the final compiling</p>

<p>4.2, Macrogenerators, page 47</p>

<p>Macrogeneration seems to be particularly valuable when a semantic extension of the
language is required</p>

<p>4.2, Macrogenerators, page 47</p>

<p>I believe, a proper aim for programming language designers to try to make the use of
macrogenerators wholly unnecessary</p>

<p>4.2, Macrogenerators, page 47</p></blockquote>

<h3>funny comments</h3>

<blockquote><p>One important characteristic of mathematics is our habit of using names for things</p>

<p>3.3.1 Variables, page 22</p>

<p>if this turns out to be difficult, the subject of a comment</p>

<p>3.4.5 Functions and routines, page 30</p>

<p><strong>Bag or Coll</strong> This is a new sort of collection for which there is, as yet, no generally accepted name.</p>

<p>3.7.7, Other forms of structure, page 45</p></blockquote>

<h2>Review</h2>

<p>This has been a very interesting paper, on the foundational concepts. A more formal approach to the assignment operator, L-Values and R-Values and functions.</p>

<p>The part about types is very interesting, explained in simple terms and with examples.</p>

<p>Some of the examples are in CPL, that although an old language, it is still comprehensible. The examples or equivalences in lambda calculus are more difficult to understand (I had to read an introduction to it<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>, just to grab the basics)</p>

<p>Some concepts are a bit outdated, such as the missing object orientation (or its features) or the assembly code, but in general the contents resist the time.</p>

<p>Many of the concepts in programming are around L-Values and R-Values and this paper has made me realize this. Also that even if we are users of these systems, I didn&rsquo;t know many formalities behind it (assignment operator, rewriting, types, type inference, polymorphism modes, polymorphism without inheritance, etc).</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Quine, W.V. Word and Object. New York Technology Press and Wiley, 1960<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p><a href="../../../../2015/07/01/self-study-in-july-2015">introduction to lambda calculus</a>, search for &ldquo;A Tutorial Introduction to the Lambda Calculus&rdquo;<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Self-study in July 2015]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/01/self-study-in-july-2015/"/>
    <updated>2015-07-01T01:08:10+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/01/self-study-in-july-2015</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve grouped all small posts related to the self-study from July 2015 into a single post</p>

<h2>Clojure made simple</h2>

<p>I&rsquo;ve watched <a href="https://www.youtube.com/watch?v=VSdnJDO-xdg">this talk</a> by Rich Hickey at the Java One. It references the talk <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Easy made simple</a></p>

<ul>
<li>polymorphism without inheritance; single dispatch on the first parameter</li>
</ul>


<h2>Productive pair programming</h2>

<p>I&rsquo;ve read <a href="http://www.carlosble.com/2015/07/productive-pair-programming/">this article</a> about pair programming, using the driver &amp; copilot technique, written by Carlos Blé</p>

<h2>Building Automated REST APIs with Python</h2>

<p>Investigating QA automation for REST APIs, I&rsquo;ve read <a href="http://www.slideshare.net/jeffknupp/building-automated-rest-apis-with-python">these slides</a> about it</p>

<h2>Backwards Compatibility Testing For Your Clojure Project</h2>

<p>I&rsquo;ve read <a href="http://blog.jenkster.com/2014/02/backwards-compatibility-testing-your-clojure-project.html">this article</a> on making leiningen test the application on several clojure versions. Written by Kris Jenkins.</p>

<h2>Succeeding with Automated Integration Tests</h2>

<p>I&rsquo;ve read <a href="http://jeremydmiller.com/2015/06/25/succeeding_with_integration_testing/">this article</a> by Jeremy Miller on integration testing and how to succeed with it. Some notes:</p>

<ul>
<li>Choose the Quickest, Useful Feedback Mechanism, even if that means testing the backend and frontend separately</li>
<li>Prefer white-box than black-box testing</li>
<li>Use quick tests, that can be run locally in an easy fashion</li>
<li>Do not share databases, as they introduce risks of flaky tests</li>
</ul>


<h2>Applied DDD in a Java EE 7 and Open Source World</h2>

<p>I&rsquo;ve watched <a href="https://www.youtube.com/watch?v=9D_-7E7Mrzw">this video</a> by Edson Yanaga in the Java One, about DDD using Java EE 7, JSFs and lambdas on top of glassfish</p>

<h2>Integrated tests are a scam</h2>

<p>I&rsquo;ve read, again, <a href="http://blog.thecodewhisperer.com/2010/10/16/integrated-tests-are-a-scam/">this article</a> by J. B. Rainsberger on integrated tests and why not to use them. From a numerical / combinatorics point of view.</p>

<h2>Functional Programming should be your #1 priority for 2015</h2>

<p>I&rsquo;ve read <a href="https://medium.com/@jugoncalves/functional-programming-should-be-your-1-priority-for-2015-47dd4641d6b9">this introduction</a> to functional programming by Ju Gonçalves. Explains some functional concepts, such as:</p>

<ul>
<li>First-Class Functions</li>
<li>High-Order Functions</li>
<li>Pure Functions</li>
<li>Closures</li>
<li>Immutable State</li>
</ul>


<p>Also recommends a few books on the subject (e.g., SICP, HTDP).</p>

<h2>A Tutorial Introduction to the Lambda Calculus</h2>

<p>I&rsquo;ve read <a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">this paper</a>, an introduction to the lambda calculus. Haven&rsquo;t done the exercises. Written by Raúl Rojas</p>

<h2>20 common mistakes when doing Test-Driven Development</h2>

<p>I had thought of converting all of <a href="https://twitter.com/search?q=svpino%20%23tdd%20mistake&amp;src=typd">his tweets</a> into a blog post, but he has already done this for us: I&rsquo;ve read a <a href="https://blog.svpino.com/2015/05/29/20-common-mistakes-when-doing-test-driven-development">list of common mistakes</a> when doing TDD by <a href="https://twitter.com/svpino">Santiago Pino</a></p>

<h2>Reducing coupling</h2>

<p>I&rsquo;ve read the article by Martin Fowler <a href="http://martinfowler.com/ieeeSoftware/coupling.pdf">Reducing Coupling</a> in the IEEE SOFTWARE July/August 2001</p>

<h2>Comparing Java Mock Frameworks – Part 2: Creating Mock Objects</h2>

<p><a href="https://softwareinabottle.wordpress.com/2010/10/06/comparing-java-mock-frameworks-part-2-creating-mock-objects/">List of mock frameworks for java</a>. Have only read the jMock, mockito and jMockit part.</p>

<h2> Software Craftsmanship book review</h2>

<p>I&rsquo;ve read <a href="http://meaganwaller.com/software-craftsmanship-book-review/">this review</a> for a book that is already pending in my book list: Software Craftsmanship by Pete McBreen.</p>

<p>The review has been written by Megan Waller, an (ex-)apprentice at 8th Light.</p>

<h2>Fundamental concepts in programming languages</h2>

<p>I&rsquo;ve read <a href="http://www.cs.cmu.edu/~crary/819-f09/Strachey67.pdf">this paper</a> containing the contents for lectures in Computer Programming in the year 1967. Written by Christopher Strachey.</p>

<p>Note: I&rsquo;ve also seen this paper recommended in the repo <a href="https://github.com/papers-we-love/papers-we-love/tree/master/plt">Papers We Love > plt</a> (Programming Language Theory)</p>

<h2>What is reification?</h2>

<p>I&rsquo;ve read <a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/TechnicalDetails.html#FAQ101A">this FAQ</a> on reification by Angelika Langer</p>

<h2>Type erasure</h2>

<p>I&rsquo;ve read this wikipedia <a href="https://en.wikipedia.org/wiki/Type_erasure">page on type erasure</a></p>

<h2>How to make an IntelliJ IDEA plugin in less than 30 minutes</h2>

<p>I&rsquo;ve read <a href="http://bjorn.tipling.com/how-to-make-an-intellij-idea-plugin-in-30-minutes">this article</a> on creating new IntelliJ IDEA plugin, by Bjorn Tipling</p>

<h2>How to Write Clean, Testable Code</h2>

<p>I&rsquo;ve watched, again, <a href="https://www.youtube.com/watch?v=XcT4yYu_TTs">this video</a> by Miško Hevery. Discusses what are the characteristics of tested and untested code, how to get from one to the other. Discusses techniques for testing code. At the end, there are questions but they cannot be heard (lack of microphone), so it is harder to follow.</p>

<h2>How to Find a Mentor</h2>

<p>I&rsquo;ve read <a href="https://medium.com/letters-to-my-mother/how-to-find-a-mentor-27fb978a8f1">this opinion</a> on the importance of role models and mentors. The difference between them and a personal experience. Written by Joanne Wilson</p>

<h2>Type theory</h2>

<p>I&rsquo;ve read this wiki page on <a href="https://en.wikipedia.org/wiki/Type_theory">type theory</a></p>

<p>Some notes:</p>

<ul>
<li>&ldquo;type systems [&hellip;] language feature used to reduce bugs&rdquo;</li>
<li>two types: Church&rsquo;s typed λ-calculi and Martin-Löf&rsquo;s intuitionistic type theory.</li>
<li>notation:

<ul>
<li>typing judgement: <code>M : A</code>. Term <code>M</code> has type <code>A</code></li>
<li>example: <code>nat</code> may be a type</li>
<li><code>2 : nat</code>, like in Scala</li>
<li>function: &ldquo;arrow&rdquo;</li>
<li>apply function to argument: no parenthesis</li>
</ul>
</li>
<li>conversion rule: rule for rewriting terms

<ul>
<li>reduction rule: conversion rule that only works in one direction</li>
</ul>
</li>
<li>normal form: a form that cannot be further reduced</li>
<li>element: all closed elements that can be reduced to the same normal form</li>
<li>closed term: a term without parameters. Opposite is an open term</li>
<li>convertibility: property of terms, both open and closed. Said to be convertible if two terms can be reduced to the same term

<ul>
<li>warning: x + 1 and 1 + x are not convertible because they are in normal form and not the same</li>
</ul>
</li>
</ul>


<h2>Type system</h2>

<p>I&rsquo;ve read this wiki page on <a href="https://en.wikipedia.org/wiki/Type_system">type system</a></p>

<p>Some notes:</p>

<ul>
<li>&ldquo;The depth of type constraints and the manner of their evaluation affect the typing of the language&rdquo;</li>
<li>Type polymorphism</li>
<li>{compile time, runtime} x {manually annotated, inferred}</li>
<li>&ldquo;A program associates each value with at least one particular type, but it also can occur that one value is associated with many subtypes.&rdquo;</li>
<li>Classification of types:

<ul>
<li>data type – a type of a value</li>
<li>class – a type of an object</li>
<li>kind – a type of a type, or metatype</li>
</ul>
</li>
<li>the type inference might be undecidable (for more complex type inference)</li>
<li>&ldquo;Strong typing offers more safety, but cannot guarantee complete type safety.&rdquo; An example is the division by zero, altough some languages may declare a dependent type &ldquo;non-zero numbers&rdquo;</li>
</ul>


<h2>The 3 things you should know about hashCode()</h2>

<p>I&rsquo;ve read <a href="http://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/">this article</a> on the hashCode() method in java, written by Ralf Sternberg.</p>

<h2>What is new in SQL:2011</h2>

<p>I&rsquo;ve read <a href="http://www.sigmod.org/publications/sigmod-record/1203/pdfs/10.industry.zemke.pdf">this white paper</a> on the new features in SQL 2011. Written by Fred Zemke</p>

<h2>5 Error Tracking Tools Java Developers Should Know</h2>

<p>I&rsquo;ve read <a href="http://www.javacodegeeks.com/2014/09/5-error-tracking-tools-java-developers-should-know.html">this article</a> about tracking tools for java written by Alex Zhitnitsky, featuring:</p>

<ul>
<li>Raygun</li>
<li>Sentry</li>
<li>Takipi</li>
<li>Airbrake</li>
<li>StackHunter</li>
<li>[Bonus] ABRT</li>
<li>Comments cite <a href="http://squash.io">Squash</a> (server written in ruby, java client available) and <a href="http://rollbar.com">Rollbar</a> (home says supports android but not says anything about java)</li>
</ul>


<h2>Data clump</h2>

<p>I&rsquo;ve read <a href="http://martinfowler.com/bliki/DataClump.html">this article</a> on the bliki, by Martin Fowler</p>

<h2>NP-Complete problems</h2>

<p>I&rsquo;ve read <a href="http://webdiis.unizar.es/asignaturas/TC/wp/wp-content/uploads/2012/01/L15_NPcompletos.pdf">these slides</a> by Prof. Elvira Mayordomo about NP-Complete problems, how to reduce them to other problems and practical applications. (In Spanish)</p>
]]></content>
  </entry>
  
</feed>
