<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Open-discussion | The long way through Software Craftsmanship]]></title>
  <link href="http://alvarogarcia7.github.io/blog/categories/open-discussion/atom.xml" rel="self"/>
  <link href="http://alvarogarcia7.github.io/"/>
  <updated>2015-06-29T00:17:06+02:00</updated>
  <id>http://alvarogarcia7.github.io/</id>
  <author>
    <name><![CDATA[alvaro garcia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Open Discussion: Behaviour-Driven Development]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/02/15/open-discussion-behaviour-driven-development/"/>
    <updated>2015-02-15T02:30:38+01:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/02/15/open-discussion-behaviour-driven-development</id>
    <content type="html"><![CDATA[<p>This week we had a great discussion about Behavior Driven Development (BDD). We have explained it as a way of developing software based on requirements, via automatically tested specifications. For more information, see the <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">wikipedia&rsquo;s article on the subject</a></p>

<p>I forgot to mention that this is the perfect start to TDD, as this is usually called the double-loop TDD. See a post on it on <a href="http://coding-is-like-cooking.info/2013/04/outside-in-development-with-double-loop-tdd/">coding is like cooking</a></p>

<p>In this double-loop TDD, the first thing is to create a BDD scenario, run it (red-1), create a unit test that reflects this red (red-2), pass it, refactor; go to red-1 as many times as you need, doing TDD cycles. When you think the feature is done, execute the BDD scenarios and go to green (outer layer) and refactor.</p>

<h2>(Our) Common setting</h2>

<p>Going back to BDD, a common scenario would be the following:</p>

<p>Layers of software:</p>

<ul>
<li>Domain-Specific Language (DSL). See <a href="http://en.wikipedia.org/wiki/Domain-specific_language">wikipedia&rsquo;s article</a></li>
<li>Test adapter: an interpreter for this DSL</li>
<li>Test software: test fixtures, methods, structures to arrange, act, and assert on the sut</li>
<li>Production software (system under test - SUT): thing being tested</li>
</ul>


<h2>A BDD test vs A TDD test</h2>

<p>Let&rsquo;s imagine a BDD test for a <a href="http://en.wikipedia.org/wiki/Linked_list">linked list</a>:</p>

<pre><code>Given I have an empty list
When I add an element
Then I have an element on the list
</code></pre>

<p>now, the same test in TDD [using java, junit 4, hamcrest]</p>

<pre><code class="java">@Test
public void add_an_element_to_an_empty_list(){
    MyLinkedList linkedList = new MyLinkedList();

    linkedList.add("something");

    assertThat(linkedList.size(), is(1));
}
</code></pre>

<p>In some aspects, a BDD and a TDD test are similar:</p>

<ul>
<li>the given is the arrange, i.e., the prerequisite</li>
<li>the when is the act, i.e., the command</li>
<li>the then is the assertion, i.e., the postcondition</li>
</ul>


<p>(for more information on this, see <a href="http://en.wikipedia.org/wiki/Hoare_logic">Hoare&rsquo;s triple</a>)</p>

<p>But in others, they are not. In BDD you do not specify the APIs, methods, etc. You only care about behavior.</p>

<h2>Conclusion</h2>

<p>Benefits:</p>

<ul>
<li>everyone might involved in the specification by example workshops (source: <a href="http://www.amazon.com/ATDD-Example-Test-Driven-Development-Addison-Wesley/dp/0321784154">ATDD by example</a>)</li>
<li>live specifications. managers can now understand the real state</li>
<li><a href="http://en.wikipedia.org/wiki/Regression_testing">regression tests</a> are much cheaper (from automation)</li>
</ul>


<p>Gotchas:</p>

<ul>
<li>Test only the happy paths</li>
<li>This has a cost, do not overdo it</li>
<li>Doesn&rsquo;t remove manual tests</li>
<li>How do you manage multiple scenarios</li>
<li>How fast should it be?</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Open Discussion: On Code Reviews]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/02/07/open-discussion-on-code-reviews/"/>
    <updated>2015-02-07T18:54:54+01:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/02/07/open-discussion-on-code-reviews</id>
    <content type="html"><![CDATA[<p>At a client, I organized an open discussion on code reviews. We had a great conversation.</p>

<p>The main idea was to discuss about it and share the ideas each one had. I didn&rsquo;t want it to turn into a masterclass (see <a href="http://chimera.labs.oreilly.com/books/1234000001813/ch02.html#the_white_belt">the white belt</a>)</p>

<h2>Benefits</h2>

<p>These are the main benefits we saw in it:</p>

<ul>
<li>Increased trust</li>
<li>Learning from others, other approaches</li>
<li>Less defects, more quality</li>
<li>Increased <a href="http://en.wikipedia.org/wiki/Bus_factor">bus factor</a>, decreased information silos</li>
<li>Also:

<ul>
<li>Getting out of your comfort zone</li>
<li>Communicating more often (code style, edge cases, complaining, etc)</li>
</ul>
</li>
</ul>


<h2>Pair programming</h2>

<p>Then we discussed about the topic of <a href="/blog/categories/code-review">code reviews</a> and <a href="/blog/categories/pair-programming/">pair programming</a>:</p>

<ul>
<li><p>How do they mix</p>

<ul>
<li>Is the need for code review reduced when doing pair programming?</li>
<li>It is cheaper to catch defects when pairing than code review (e.g., less to modify, mental caches are hot, &hellip;), so why do code reviews? <a href="https://twitter.com/jbrains">J. B. Rainsberger</a> has an <a href="http://us2.campaign-archive2.com/?u=80ca60ec48ef77dfaa1f38943&amp;id=acc77a0fb2&amp;e=4a925444f9">article</a> about it</li>
</ul>
</li>
<li><p>Does it give you the same benefits?</p>

<ul>
<li>I argued that it does, some of my colleagues argued against as one is &ldquo;while doing&rdquo; and the other is after.</li>
</ul>
</li>
</ul>


<h2>Practice, Practice, Practice</h2>

<p>This is also a reference to a chapter by the same name (<a href="http://chimera.labs.oreilly.com/books/1234000001813/ch05.html#practice_comma_practice_comma_practice">here</a>)</p>

<p>We proposed this problem:</p>

<blockquote><p>Receive a list of numbers to a command-line (CLI) application and print their sum</p></blockquote>

<p>I wrote simple code listing and we reviewed it. The code is <a href="https://gist.github.com/alvarogarcia7/258faea12cb9375539fe">here as a gist</a></p>

<p>(Just in case, I wrote this listing with some defects / smells on purpose)</p>

<p>Here are the comments:</p>

<ul>
<li>Not all parameters will be added, only the first three</li>
<li>The parameters are out of order, overcomplicating things. Is it due to something? Should I be careful about it?</li>
<li>There is duplication (i.e., parsing from string)</li>
<li>Bad naming: what is <code>a</code>, <code>b</code>, <code>c</code>?</li>
<li>There are no tests for it. No manual / javadoc either. Therefore, it&rsquo;s difficult to maintain</li>
<li><p>Difficult to test: a smell for bad design?</p>

<ul>
<li>How to test the adding by itself? The output is to the console, so we have to capture it (at GMaur we published this tool: <a href="https://github.com/GMaur/legacyutils">legacyUtils</a>)</li>
<li>How to test the parsing if there is no mock to be injected? Only via state tests, therefore &ldquo;end to end&rdquo; tests as it includes the adding</li>
</ul>
</li>
<li><p>Mixed concerns / responsibilities. Parsing the numbers and adding them are different concerns and should not be together</p></li>
</ul>


<h2>Conclusion</h2>

<ul>
<li>No one was against it</li>
<li>We all agreed that is important to do it even in time-constrained environments</li>
<li>It is also important to review our code reviews to make the most of it. The article by <a href="http://us2.campaign-archive2.com/?u=80ca60ec48ef77dfaa1f38943&amp;id=acc77a0fb2&amp;e=4a925444f9">J. B. Rainsberger</a> is quite useful for that</li>
<li>Even small codes can be bad and need to be reviewed (as the example)</li>
<li>Quick and dirty proof of concept do not mix well with code reviews</li>
</ul>

]]></content>
  </entry>
  
</feed>
