<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | The long way through Software Craftsmanship]]></title>
  <link href="http://alvarogarcia7.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://alvarogarcia7.github.io/"/>
  <updated>2015-08-10T01:18:11+02:00</updated>
  <id>http://alvarogarcia7.github.io/</id>
  <author>
    <name><![CDATA[alvaro garcia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Language Was Prepared for That]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/08/10/the-language-was-prepared-for-that/"/>
    <updated>2015-08-10T00:58:33+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/08/10/the-language-was-prepared-for-that</id>
    <content type="html"><![CDATA[<p>Many times I&rsquo;ve written this function:</p>

<pre><code class="java">public boolean between(int lowerBound, int n, int upperBound){
    return lowerBound &lt;= n &amp;&amp;
        n &lt;= upperBound;
}
</code></pre>

<p>It may depend on the case, whether it is <code>[]</code>, <code>[)</code>, <code>(]</code> or <code>()</code>, to use mathematical terms.</p>

<p>When the two comparisons are the same (<code>[]</code> and <code>()</code>), there is duplication in the comparisons.</p>

<p>Investigating a little bit on this in clojure, I&rsquo;ve found this function:</p>

<pre><code class="lisp">&lt;=
</code></pre>

<p>And its <a href="https://clojuredocs.org/clojure.core/%3C=">clojuredocs</a>: Returns non-nil if nums are in monotonically non-decreasing order,
otherwise false.</p>

<p>A sample usage:</p>

<pre><code class="lisp">(&lt;= 1 2)
; true

(&lt;= 1 2 1)
; false
</code></pre>

<p>The last part is the most interesting one. As this function is prepared to receive more than two parameters, it is very easy for the programmer to use it. We could say that the language was prepared for that.</p>

<p>The <a href="https://github.com/clojure/clojure/blob/clojure-1.7.0/src/clj/clojure/core.clj#L1020">implementation</a>:</p>

<pre><code class="lisp">(defn &lt;=
  ([x] true)
  ([x y] (. clojure.lang.Numbers (lte x y)))
  ([x y &amp; more]
   (if (&lt;= x y)
     (if (next more)
       (recur y (first more) (next more))
       (&lt;= y (first more)))
     false)))
</code></pre>

<p>Inspired by this, I&rsquo;ve implemented the same function in haskell (for the repl):</p>

<pre><code class="haskell">let isBigger acc ele = (snd acc) &amp;&amp; (fst acc) &lt; ele in
   foldl (\acc ele -&gt; (ele, isBigger acc ele)) (1, True) [1,2,1,3] 
</code></pre>

<p>and a simpler solution I&rsquo;ve found on <a href="http://codereview.stackexchange.com/questions/46606/is-a-list-sorted/46608#46608">Stack Overflow</a>:</p>

<pre><code class="haskell">isSorted :: (Ord a) =&gt; [a] -&gt; Bool
isSorted xs = all (\(x, y) -&gt; x &lt;= y) $ zip xs (tail xs)
</code></pre>

<p>or</p>

<pre><code class="haskell">isSorted :: (Ord a) =&gt; [a] -&gt; Bool
isSorted xs = and $ zipWith (&lt;=) xs (tail xs)
</code></pre>

<h2>Conclusion</h2>

<p>Unless a more elegant, language-provided solution exists in haskell, the clojure one is way simpler. This is one of the benefits of prefix notation, that operators (e.g., <code>+</code>, <code>-</code>, <code>*</code>, <code>&lt;=</code>) are overloaded to take more arguments than before.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiple Return Values in a Mockito Stub]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/08/07/multiple-values-in-a-mockito-stub/"/>
    <updated>2015-08-07T11:31:19+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/08/07/multiple-values-in-a-mockito-stub</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been asked today how to return multiple return values from a Mockito Spy, effectively using the spy as a Stub, as well.</p>

<pre><code class="java">package com.example.spike;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

import org.junit.Test;
import org.mockito.Spy;

public class DifferentReturnValues {

    @Spy
    private Spike1 spike1 = new Spike1();


    @Test
    public void spike1() {
        spike1 = spy(spike1);
        when(spike1.getBool()).thenReturn(false, true);

        assertThat(spike1.getBool(), is(false));
        assertThat(spike1.getBool(), is(true));

        assertThat(spike1.getBool(), is(true));
        assertThat(spike1.getBool(), is(true));
    }


    private class Spike1 {
        public boolean getBool() {
            return true;
        }
    }
}
</code></pre>

<p>The key line is:</p>

<pre><code class="java">when(spike1.getBool()).thenReturn(false, true);
</code></pre>

<p>this makes the stubbed function to return multiple values:</p>

<pre><code class="java">assertThat(spike1.getBool(), is(false));
assertThat(spike1.getBool(), is(true));
</code></pre>

<p>The last value is repeated after the last defined value:</p>

<pre><code class="java">@Test
public void spike1() {
    spike1 = spy(spike1);
    when(spike1.getBool()).thenReturn(false, true);

    assertThat(spike1.getBool(), is(false));
    assertThat(spike1.getBool(), is(true));

    assertThat(spike1.getBool(), is(true));
    assertThat(spike1.getBool(), is(true));
}
</code></pre>

<p>If you want to loop over the values, you can implement it with the <code>doAnswer</code> method:</p>

<pre><code class="java">@Test
public void spike1() {
    spike1 = spy(spike1);
    when(spike1.getBool()).thenReturn(false, true);

    final boolean[] value = {true};

    doAnswer(invocation -&gt; {
        value[0] = !value[0];
        return value[0];
    }).when(spike1).getBool();

    assertThat(spike1.getBool(), is(false));
    assertThat(spike1.getBool(), is(true));

    assertThat(spike1.getBool(), is(false));
    assertThat(spike1.getBool(), is(true));
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tool to Find Duplicate Values in Constants]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/30/tool-to-find-duplicate-values-in-constants/"/>
    <updated>2015-07-30T13:42:44+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/30/tool-to-find-duplicate-values-in-constants</id>
    <content type="html"><![CDATA[<p>Imagine having this java class:</p>

<pre><code class="java">private static class RepeatedConstants {
    public static final String A = "A";
    public static final String A_1 = A;
    public static final String A_2 = "A";

    public static final Integer _3 = 3;
    public static final Integer THREE = 3;
}
</code></pre>

<p>I wanted to remove the repeated values in the constants, in an automatic way, because the file was big (> 4000 constants). A way of doing this is basing the differences on the values, directly. To do this, remove all text that is not a value:</p>

<p>find what, regex mode: <code>^.*=\s*(.*);</code>
replace with: $1</p>

<p>Explanation:</p>

<ul>
<li><code>^.*=\s*</code>: any character before the equal sign. Any whitespace right after it.</li>
<li><code>(.*);</code>: capture everything that is before the semicolon (;)</li>
</ul>


<p>You end up with this:</p>

<pre><code>"A"
A
"A"

3
3
</code></pre>

<p>Copy it to <code>a.txt</code>, <code>sort</code> it and <code>uniq</code> it (to remove duplication):</p>

<pre><code class="bash">cat a.txt | sort | uniq &gt; uniq.txt
</code></pre>

<p>then sort the non-uniq version:</p>

<pre><code class="bash">cat a.txt | sort &gt; sorted.txt
</code></pre>

<p>and diff among them, to find the repeated values:</p>

<pre><code class="bash">diff sorted.txt uniq.txt

3,4d2
&lt; "A"
&lt; 3
</code></pre>

<p>These are the repeated values. The variable <code>   public static final String A_1 = A;</code> was not caught by this as it only has the same value in execution, not staticly.</p>

<p>For this, at Gmaur, we have developed a small <a href="https://github.com/GMaur/java-duplicates-detector">module to detect duplicates</a>. The main code is this:</p>

<pre><code class="java">public class RepeatedFinder {

  private final Class aClass;

  public RepeatedFinder(Class aClass) {
    this.aClass = aClass;
  }

  public MultiMap findDuplicates() throws IllegalAccessException {
    return generateMapFromValueToVariables(aClass).valuesWithMoreThanOneVariable();
  }

  private ValueToNameRepository generateMapFromValueToVariables(Class&lt;?&gt; clazz) throws IllegalAccessException {
    ValueToNameRepository valueToNames = new ValueToNameRepository();
    Field[] fields = clazz.getDeclaredFields();
    Object object = new Object();
    for (Field field : fields) {
      Object value = field.get(object);
      valueToNames.add(value, field.getName());
    }
    return valueToNames;
  }
</code></pre>

<p>The tests and the source code can be found here: <a href="https://github.com/GMaur/java-duplicates-detector">https://github.com/GMaur/java-duplicates-detector</a></p>

<p>Hope you enjoy it, as much as we have enjoyed writing it!</p>

<p>Any feedback is welcome.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploring Testing With Java 8 Lambdas]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/30/exploring-testing-with-java-8-lambdas/"/>
    <updated>2015-07-30T13:04:10+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/30/exploring-testing-with-java-8-lambdas</id>
    <content type="html"><![CDATA[<p>At a client, we were testing a simple feature, but the resulting tests had much subtle repetition:</p>

<p>(source code is <a href="https://github.com/alvarogarcia7/spike-lambda-testing/tree/ef00a220f427900e3180dcbeec51248845446248">here</a>)</p>

<pre><code class="java">@Test
public void log_when_sending_greeting_letters() {

    sut.send(mock(GreetingLetter.class));

    verify(logger).sentGreetingLetter();
}

@Test
public void log_when_sending_love_letters() {

    sut.send(mock(LoveLetter.class));

    verify(logger).sentLoveLetter();
}
</code></pre>

<p>and the production code:</p>

<pre><code class="java">public class MailSender {
    private final EventLogger eventLogger;

    public MailSender (final EventLogger eventLogger) {
        this.eventLogger = eventLogger;
    }

    public void send (final GreetingLetter letter) {
        // more business logic
        eventLogger.sentGreetingLetter();
    }

    public void send (final LoveLetter letter) {
        // more business logic
        eventLogger.sentLoveLetter();
    }
}
</code></pre>

<p>Note: this is an adapted code, so the business logic is not complete and seems simple.</p>

<p>So I decided to explore a bit on refactoring these tests to use lambdas and reduce repetition:</p>

<pre><code class="java">private MailSender sut;
private Consumer&lt;MailSender&gt; arrange;
private Consumer&lt;EventLogger&gt; verify;

@Test
public void log_greetings_letter() {
    arrange = (MailSender sut) -&gt; sut.send(mock(GreetingLetter.class));

    verify = EventLogger::sentGreetingLetter;

    assertAndVerify();
}

@Test
public void log_love_letter() {
    arrange = (MailSender sut) -&gt; sut.send(mock(LoveLetter.class));

    verify = EventLogger::sentLoveLetter;

    assertAndVerify();
}

private void assertAndVerify() {
    arrange.accept(sut);
    verify.accept(logger);
}
</code></pre>

<p>Some comments, mine and my teammates:</p>

<ul>
<li>The tests are not very readable, maybe because we&rsquo;re still not used to java 8 lambdas</li>
<li><code>assertAndVerify</code> has multiple purposes / responsibilities</li>
<li>The gain of usability does not outweight the loss of readability</li>
</ul>


<p>Finally, the refactor was discarded and we are using the initial version.</p>

<p>Later, in the dojo, <a href="https://twitter.com/@trikitrok">Manuel</a> and I have refactored this a little bit more. Source code is <a href="https://github.com/alvarogarcia7/spike-lambda-testing/tree/8e3dbecd91e1ead33c5b3f6560e2a786c36b0de9">here</a></p>

<pre><code class="java">public class MailSenderShould {

    private EventLogger eventLogger;
    private MailSender mailSender;

    @Before
    public void setUp () {
        eventLogger = mock(EventLogger.class);
        mailSender = new MailSender(eventLogger);
    }

    @Test
    public void log_greetings_letter() {
        checkThat(aLoggingLine().forA(greetingLetter()).wasLoggedWhen(aGreetingLetterWasSent()));
    }

    @Test
    public void log_love_letter() {
        checkThat(aLoggingLine().forA(loveLetter()).wasLoggedWhen(aLoveLetterWasSent()));
    }

    private void checkThat (final Check check) {
        check.checkFor(mailSender, eventLogger);
    }

    private Consumer&lt;EventLogger&gt; aGreetingLetterWasSent () {
        return EventLogger::sentGreetingLetter;
    }

    private Consumer&lt;MailSender&gt; greetingLetter () {
        return (MailSender sut) -&gt; sut.sendGreetingLetter(mock(GreetingLetter.class));
    }

    private Consumer&lt;MailSender&gt; loveLetter () {
        return (MailSender sut) -&gt; sut.sendLoveLetter(mock(LoveLetter.class));
    }

    private Consumer&lt;EventLogger&gt; aLoveLetterWasSent () {
        return EventLogger::sentLoveLetter;
    }
}
</code></pre>

<p>(the logger is <a href="https://github.com/alvarogarcia7/spike-lambda-testing/blob/8e3dbecd91e1ead33c5b3f6560e2a786c36b0de9/src/test/java/com/example/lambdatesting/CheckBuilder.java">here</a>)</p>

<p>Later, we have created a simpler functional DSL for the logging, joining the <code>act</code> and <code>verify</code> into an object called <code>Check</code></p>

<pre><code class="java">public class MailSenderShould {

    private EventLogger eventLogger;
    private MailSender mailSender;

    @Before
    public void setUp () {
        eventLogger = mock(EventLogger.class);
        mailSender = new MailSender(eventLogger);
    }

    @Test
    public void log_greetings_letter() {
        mailSenderLogs(whenSendingAGreetingLetter());
    }

    @Test
    public void log_love_letter() {
        mailSenderLogs(whenSendingALoveLetter());
    }

    private Check whenSendingALoveLetter () {
        return new Check(
            (MailSender sut) -&gt; sut.send(letter(LoveLetter.class)),
            EventLogger::sentLoveLetter
        );
    }

    private void mailSenderLogs (Check check) {
        check.checkFor(mailSender, eventLogger);
    }

    private Check whenSendingAGreetingLetter () {
        return new Check(
            (MailSender sut) -&gt; sut.send(letter(GreetingLetter.class)),
            EventLogger::sentGreetingLetter
        );
    }

    private &lt;T&gt; T letter (final Class&lt;T&gt; typeOfLetter) {
        return mock(typeOfLetter);
    }
}
</code></pre>

<p>and the <code>Check</code>, just a placeholder for two <code>Consumer</code>s:</p>

<pre><code class="java">public class Check {

    private final Consumer&lt;MailSender&gt; act;
    private final Consumer&lt;EventLogger&gt; verify;

    public Check (final Consumer&lt;MailSender&gt; act, final Consumer&lt;EventLogger&gt; verify) {
        this.act = act;
        this.verify = verify;
    }

    public void checkFor(MailSender mailSender, EventLogger eventLogger) {
        act.accept(mailSender);
        verify.accept(eventLogger);
    }
}
</code></pre>

<h2>Comparison</h2>

<p>Comparison between the original form and the three refactored forms of the test:</p>

<pre><code class="java">@Test
public void log_when_sending_greeting_letters() {

    sut.send(mock(GreetingLetter.class));

    verify(logger).sentGreetingLetter();
}
</code></pre>

<p>This reads like a classical JUnit tests, using the interaction (with mocks).</p>

<pre><code class="java">@Test
public void log_greetings_letter() {
    arrange = (MailSender sut) -&gt; sut.send(mock(GreetingLetter.class));

    verify = EventLogger::sentGreetingLetter;

    assertAndVerify();
}
</code></pre>

<p>This is the first step towards more cohesion, at the cost of readability. You save the verify at the end, but the repeated method <code>assertAndVerify</code> is still present.</p>

<pre><code class="java">@Test
public void log_greetings_letter() {
    checkThat(aLoggingLine().forA(greetingLetter()).wasLoggedWhen(aGreetingLetterWasSent()));
}
</code></pre>

<p>This one reads more like a classical DSL, but is harder to read compared to a classical test.</p>

<pre><code class="java">@Test
public void log_greetings_letter() {
    mailSenderLogs(whenSendingAGreetingLetter());
}
</code></pre>

<p>This one reads more like a business requirement.</p>

<h2>Other</h2>

<p>Other ideas we have tested:</p>

<pre><code class="java">Builder.aNew().sendGreetingLetter()

assertAndVerifyThat(
    theLoggingLine()
        .for(aGreetingLetter())
        .isLoggedWhen(greetingLetterIsSent()
    )
);

public Consumer&lt;MailSender&gt; aGreetingLetter(){
    return (MailSender sut) -&gt; sut.sendGreetingLetter(mock(GreetingLetter.class));
}

public Consumer&lt;EventLogger&gt; greetingLetterIsSent(){
    return EventLogger::sentGreetingLetter;
}
</code></pre>

<pre><code class="java">assertAndVerifyThat(
    theLoggingLine()
        .for(
            (MailSender sut) -&gt; sut.sendGreetingLetter(mock(GreetingLetter.class))
        )
        .isLoggedWhen(EventLogger::sentGreetingLetter)
    )
);
</code></pre>

<pre><code class="java">public void assertAndVerifyThat(TestContext testContext){
    testContext.assert();
    testContext.verify();
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Defines a Dependency]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/13/what-defines-a-dependency/"/>
    <updated>2015-07-13T07:48:28+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/13/what-defines-a-dependency</id>
    <content type="html"><![CDATA[<p>A friend and I were arguing about this code (<a href="https://github.com/alvarogarcia7/cos/blob/7bf866bdfb9006d73a0124e00152e55c520d98a4/src/main/java/users/Registry.java">fragment</a>):</p>

<pre><code class="java">public void register (final String userName)  {
    try {
        registeredUsers.add(new User(userName));
    } catch (AlreadyRegisteredUserException e) {
        resultListener.alreadyRegistered(userName);
    }
}
</code></pre>

<p>I would have said that <code>resultListener</code> is a dependency as, first, it was injected by the constructor, second, it is necessary for the execution (negative case).</p>

<p>He suggested that:</p>

<ul>
<li>being injected through  the constructor is usually what happens with dependencies, but does not make it one (i.e., something can be injected by the constructor and not be a dependency)</li>
<li>what defines a dependency is related to the business: if this behavior is mandatory for the business, then it is a dependency.</li>
</ul>


<p>As a conclusion, <code>resultListener</code> would be a notification, as business does not require it.</p>

<p>On a later commit, we decided to inject it to <code>registeredUsers</code> (<a href="https://github.com/alvarogarcia7/cos/blob/c89bec1a2de388165676f095c2218afeb1321374/src/main/java/users/InMemoryRegisteredUsers.java">fragment</a>)</p>

<pre><code class="java">public void add (User user, final RegistryResultListener resultListener) {
    if(contains(user)) {
        resultListener.alreadyRegistered(user.name());
        return;
    }

    users.add(user);
    resultListener.successfullyRegistered(user.name());
}
</code></pre>

<p>Note: for cases when no one needs to be informed about the users being registered or not, a null-object pattern will suffice, as there is no check for null reference in the parameter <code>resultListener</code>.</p>

<p>Note: more information on object stereotypes can be found <a href="../../../../2015/07/13/object-peer-stereotypes/">here</a></p>
]]></content>
  </entry>
  
</feed>
