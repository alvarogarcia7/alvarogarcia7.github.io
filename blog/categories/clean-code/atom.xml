<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Clean-code | The long way through Software Craftsmanship]]></title>
  <link href="http://alvarogarcia7.github.io/blog/categories/clean-code/atom.xml" rel="self"/>
  <link href="http://alvarogarcia7.github.io/"/>
  <updated>2015-07-13T09:02:56+02:00</updated>
  <id>http://alvarogarcia7.github.io/</id>
  <author>
    <name><![CDATA[alvaro garcia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Self-study in July 2015]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/01/self-study-in-july-2015/"/>
    <updated>2015-07-01T01:08:10+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/01/self-study-in-july-2015</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve grouped all small posts related to the self-study from July 2015 into a single post</p>

<h2>Clojure made simple</h2>

<p>I&rsquo;ve watched <a href="https://www.youtube.com/watch?v=VSdnJDO-xdg">this talk</a> by Rich Hickey at the Java One. It references the talk <a href="http://www.infoq.com/presentations/Simple-Made-Easy">Easy made simple</a></p>

<ul>
<li>polymorphism without inheritance; single dispatch on the first parameter</li>
</ul>


<h2>Productive pair programming</h2>

<p>I&rsquo;ve read <a href="http://www.carlosble.com/2015/07/productive-pair-programming/">this article</a> about pair programming, using the driver &amp; copilot technique, written by Carlos Blé</p>

<h2>Building Automated REST APIs with Python</h2>

<p>Investigating QA automation for REST APIs, I&rsquo;ve read <a href="http://www.slideshare.net/jeffknupp/building-automated-rest-apis-with-python">these slides</a> about it</p>

<h2>Backwards Compatibility Testing For Your Clojure Project</h2>

<p>I&rsquo;ve read <a href="http://blog.jenkster.com/2014/02/backwards-compatibility-testing-your-clojure-project.html">this article</a> on making leiningen test the application on several clojure versions. Written by Kris Jenkins.</p>

<h2>Succeeding with Automated Integration Tests</h2>

<p>I&rsquo;ve read <a href="http://jeremydmiller.com/2015/06/25/succeeding_with_integration_testing/">this article</a> by Jeremy Miller on integration testing and how to succeed with it. Some notes:</p>

<ul>
<li>Choose the Quickest, Useful Feedback Mechanism, even if that means testing the backend and frontend separately</li>
<li>Prefer white-box than black-box testing</li>
<li>Use quick tests, that can be run locally in an easy fashion</li>
<li>Do not share databases, as they introduce risks of flaky tests</li>
</ul>


<h2>Applied DDD in a Java EE 7 and Open Source World</h2>

<p>I&rsquo;ve watched <a href="https://www.youtube.com/watch?v=9D_-7E7Mrzw">this video</a> by Edson Yanaga in the Java One, about DDD using Java EE 7, JSFs and lambdas on top of glassfish</p>

<h2>Integrated tests are a scam</h2>

<p>I&rsquo;ve read, again, <a href="http://blog.thecodewhisperer.com/2010/10/16/integrated-tests-are-a-scam/">this article</a> by J. B. Rainsberger on integrated tests and why not to use them. From a numerical / combinatorics point of view.</p>

<h2>Functional Programming should be your #1 priority for 2015</h2>

<p>I&rsquo;ve read <a href="https://medium.com/@jugoncalves/functional-programming-should-be-your-1-priority-for-2015-47dd4641d6b9">this introduction</a> to functional programming by Ju Gonçalves. Explains some functional concepts, such as:</p>

<ul>
<li>First-Class Functions</li>
<li>High-Order Functions</li>
<li>Pure Functions</li>
<li>Closures</li>
<li>Immutable State</li>
</ul>


<p>Also recommends a few books on the subject (e.g., SICP, HTDP).</p>

<h2>A Tutorial Introduction to the Lambda Calculus</h2>

<p>I&rsquo;ve read <a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">this paper</a>, an introduction to the lambda calculus. Haven&rsquo;t done the exercises. Written by Raúl Rojas</p>

<h2>20 common mistakes when doing Test-Driven Development</h2>

<p>I had thought of converting all of <a href="https://twitter.com/search?q=svpino%20%23tdd%20mistake&amp;src=typd">his tweets</a> into a blog post, but he has already done this for us: I&rsquo;ve read a <a href="https://blog.svpino.com/2015/05/29/20-common-mistakes-when-doing-test-driven-development">list of common mistakes</a> when doing TDD by <a href="https://twitter.com/svpino">Santiago Pino</a></p>

<h2>Reducing coupling</h2>

<p>I&rsquo;ve read the article by Martin Fowler <a href="http://martinfowler.com/ieeeSoftware/coupling.pdf">Reducing Coupling</a> in the IEEE SOFTWARE July/August 2001</p>

<h2>Comparing Java Mock Frameworks – Part 2: Creating Mock Objects</h2>

<p><a href="https://softwareinabottle.wordpress.com/2010/10/06/comparing-java-mock-frameworks-part-2-creating-mock-objects/">List of mock frameworks for java</a>. Have only read the jMock, mockito and jMockit part.</p>

<h2> Software Craftsmanship book review</h2>

<p>I&rsquo;ve read <a href="http://meaganwaller.com/software-craftsmanship-book-review/">this review</a> for a book that is already pending in my book list: Software Craftsmanship by Pete McBreen.</p>

<p>The review has been written by Megan Waller, an (ex-)apprentice at 8th Light.</p>

<h2>Fundamental concepts in programming languages</h2>

<p>I&rsquo;ve read <a href="http://www.cs.cmu.edu/~crary/819-f09/Strachey67.pdf">this paper</a> containing the contents for lectures in Computer Programming in the year 1967. Written by Christopher Strachey.</p>

<p>Note: I&rsquo;ve also seen this paper recommended in the repo <a href="https://github.com/papers-we-love/papers-we-love/tree/master/plt">Papers We Love > plt</a> (Programming Language Theory)</p>

<h2>What is reification?</h2>

<p>I&rsquo;ve read <a href="http://www.angelikalanger.com/GenericsFAQ/FAQSections/TechnicalDetails.html#FAQ101A">this FAQ</a> on reification by Angelika Langer</p>

<h2>Type erasure</h2>

<p>I&rsquo;ve read this wikipedia <a href="https://en.wikipedia.org/wiki/Type_erasure">page on type erasure</a></p>

<h2>How to make an IntelliJ IDEA plugin in less than 30 minutes</h2>

<p>I&rsquo;ve read <a href="http://bjorn.tipling.com/how-to-make-an-intellij-idea-plugin-in-30-minutes">this article</a> on creating new IntelliJ IDEA plugin, by Bjorn Tipling</p>

<h2>How to Write Clean, Testable Code</h2>

<p>I&rsquo;ve watched, again, <a href="https://www.youtube.com/watch?v=XcT4yYu_TTs">this video</a> by Miško Hevery. Discusses what are the characteristics of tested and untested code, how to get from one to the other. Discusses techniques for testing code. At the end, there are questions but they cannot be heard (lack of microphone), so it is harder to follow.</p>

<h2>How to Find a Mentor</h2>

<p>I&rsquo;ve read <a href="https://medium.com/letters-to-my-mother/how-to-find-a-mentor-27fb978a8f1">this opinion</a> on the importance of role models and mentors. The difference between them and a personal experience. Written by Joanne Wilson</p>

<h2>Type theory</h2>

<p>I&rsquo;ve read this wiki page on <a href="https://en.wikipedia.org/wiki/Type_theory">type theory</a></p>

<p>Some notes:</p>

<ul>
<li>&ldquo;type systems [&hellip;] language feature used to reduce bugs&rdquo;</li>
<li>two types: Church&rsquo;s typed λ-calculi and Martin-Löf&rsquo;s intuitionistic type theory.</li>
<li>notation:

<ul>
<li>typing judgement: <code>M : A</code>. Term <code>M</code> has type <code>A</code></li>
<li>example: <code>nat</code> may be a type</li>
<li><code>2 : nat</code>, like in Scala</li>
<li>function: &ldquo;arrow&rdquo;</li>
<li>apply function to argument: no parenthesis</li>
</ul>
</li>
<li>conversion rule: rule for rewriting terms

<ul>
<li>reduction rule: conversion rule that only works in one direction</li>
</ul>
</li>
<li>normal form: a form that cannot be further reduced</li>
<li>element: all closed elements that can be reduced to the same normal form</li>
<li>closed term: a term without parameters. Opposite is an open term</li>
<li>convertibility: property of terms, both open and closed. Said to be convertible if two terms can be reduced to the same term

<ul>
<li>warning: x + 1 and 1 + x are not convertible because they are in normal form and not the same</li>
</ul>
</li>
</ul>


<h2>Type system</h2>

<p>I&rsquo;ve read this wiki page on <a href="https://en.wikipedia.org/wiki/Type_system">type system</a></p>

<p>Some notes:</p>

<ul>
<li>&ldquo;The depth of type constraints and the manner of their evaluation affect the typing of the language&rdquo;</li>
<li>Type polymorphism</li>
<li>{compile time, runtime} x {manually annotated, inferred}</li>
<li>&ldquo;A program associates each value with at least one particular type, but it also can occur that one value is associated with many subtypes.&rdquo;</li>
<li>Classification of types:

<ul>
<li>data type – a type of a value</li>
<li>class – a type of an object</li>
<li>kind – a type of a type, or metatype</li>
</ul>
</li>
<li>the type inference might be undecidable (for more complex type inference)</li>
<li>&ldquo;Strong typing offers more safety, but cannot guarantee complete type safety.&rdquo; An example is the division by zero, altough some languages may declare a dependent type &ldquo;non-zero numbers&rdquo;</li>
</ul>


<h2>The 3 things you should know about hashCode()</h2>

<p>I&rsquo;ve read <a href="http://eclipsesource.com/blogs/2012/09/04/the-3-things-you-should-know-about-hashcode/">this article</a> on the hashCode() method in java, written by Ralf Sternberg.</p>

<h2>What is new in SQL:2011</h2>

<p>I&rsquo;ve read <a href="http://www.sigmod.org/publications/sigmod-record/1203/pdfs/10.industry.zemke.pdf">this white paper</a> on the new features in SQL 2011. Written by Fred Zemke</p>

<h2>5 Error Tracking Tools Java Developers Should Know</h2>

<p>I&rsquo;ve read <a href="http://www.javacodegeeks.com/2014/09/5-error-tracking-tools-java-developers-should-know.html">this article</a> about tracking tools for java written by Alex Zhitnitsky, featuring:</p>

<ul>
<li>Raygun</li>
<li>Sentry</li>
<li>Takipi</li>
<li>Airbrake</li>
<li>StackHunter</li>
<li>[Bonus] ABRT</li>
<li>Comments cite <a href="http://squash.io">Squash</a> (server written in ruby, java client available) and <a href="http://rollbar.com">Rollbar</a> (home says supports android but not says anything about java)</li>
</ul>


<h2>Data clump</h2>

<p>I&rsquo;ve read <a href="http://martinfowler.com/bliki/DataClump.html">this article</a> on the bliki, by Martin Fowler</p>

<h2>NP-Complete problems</h2>

<p>I&rsquo;ve read <a href="http://webdiis.unizar.es/asignaturas/TC/wp/wp-content/uploads/2012/01/L15_NPcompletos.pdf">these slides</a> by Prof. Elvira Mayordomo about NP-Complete problems, how to reduce them to other problems and practical applications. (In Spanish)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What Legacy Code Is About]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/04/21/what-legacy-code-is-about/"/>
    <updated>2015-04-21T22:09:54+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/04/21/what-legacy-code-is-about</id>
    <content type="html"><![CDATA[<p>In his book <a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052/ref=sr_1_1?ie=UTF8&amp;qid=1429647115&amp;sr=8-1&amp;keywords=legacy+code+feathers">Working effectively with legacy code</a>, <a href="https://twitter.com/mfeathers">Michael Feathers</a> describes:</p>

<blockquote><p>[&hellip;] legacy code as code without tests. It is a good working definition, and it points to a solution [&hellip;]</p>

<p>M Feathers, in the preface of Working effectively with legacy code</p></blockquote>

<p>I really like this definition. It is objective and measurable. But this is also a downside. Let&rsquo;s take any concurrent code, for example: you can achieve 100% coverage on a single thread and the program could have defects when executed in parallel. But this might be an outlier, as concurrency is difficult to test. Let&rsquo;s take another example.</p>

<p>Let&rsquo;s a imagine a non-concurrent (i.e., single thread) code composed by a single class (no collaborators; just one responsibility; it is &ldquo;Clean Code&rdquo;, as defined per R.C. Martin&rsquo;s book) that has some happy paths as well as some error-handling cases. As usual. The original code writer has decided to test only the happy paths. They deployed it to production, as the product was ready. You inherit this code.</p>

<p>After the system is deployed to production, you start receiving defect reports on the happy paths (the tested part). The first one, you cross it off as an one-time thing. Then the second and third come. You take a deeper look and start seeing some inconsistencies in the tests, some tests that actually do not test anything interesting:</p>

<ul>
<li>some test the test framework</li>
<li>some the language</li>
<li>some test a happy path that works by pure luck</li>
<li>some functionalities are tested (not all happy paths)</li>
<li>there&rsquo;s actually a defect converted into a specification (test) (??)</li>
</ul>


<p>Now, I ask myself this question: when did I start considering this code as legacy? When I saw the bug reports in production (several in a row) or when I saw the poor suite of tests?</p>

<p>I do think this codebase is legacy, no matter when I realized about it. But my first instinct would be to consider it legacy from the moment I received the bug reports, as I lost the trust in that code.</p>

<p>Because for me, <strong>legacy code is about trust, not tests</strong>. You can have tests but no trust; you can have trust but no tests (the latter is more difficult in non-trivial codebases.)</p>

<p>This is why I would like to update the definition:</p>

<blockquote><p>Legacy code is code without tests that provide trust to all your stakeholders</p></blockquote>

<p>The last part is very important, because the definition is no longer objective but depends from person to person. If the codebase doesn&rsquo;t have tests, it is definitely legacy. But even if it has them, would you consider the given example a legacy or non-legacy code?</p>

<p>These stakeholders include everyone affected or affecting the product: owners, developer team (in the scrum, wide sense), users, clients, &hellip;</p>

<p>Full disclosure: I&rsquo;ve written plenty of legacy code. Code which I thought was good but really wasn&rsquo;t. Even with tests, even with TDD, even with Clean Code. This has made me change my mind about what legacy code is all about.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Legacy Code Introduction]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/02/21/a-legacy-code-introduction/"/>
    <updated>2015-02-21T20:05:46+01:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/02/21/a-legacy-code-introduction</id>
    <content type="html"><![CDATA[<p>This is one of the best legacy code introductions I&rsquo;ve seen:</p>

<blockquote><p>The Grand Redesign in the Sky</p>

<p>Eventually the team rebels. They inform management that they cannot continue to develop in this odious code base. They demand a redesign. Management does not want to expend the resources on a whole new redesign of the project, but they cannot deny that productivity is terrible. Eventually they bend to the demands of the developers and authorize the grand redesign in the sky.</p>

<p>A new tiger team is selected. Everyone wants to be on this team because it&rsquo;s a greenfield project. They get to start over and create something truly beautiful. But only the best and brightest are chosen for the tiger team. Everyone else must continue to maintain the current system.</p>

<p>Now the two teams are in a race. The tiger team must build a new system that does everything that the old system does. Not only that, they have to keep up with the changes that are continuously being made to the old system. Management will not replace the old system until the new system can do everything that the old system does.</p>

<p>This race can go on for a very long time. I&rsquo;ve seen it take 10 years. And by the time it&rsquo;s done, the original members of the tiger team are long gone, and the current members are demanding that the new system be redesigned because it&rsquo;s such a mess.</p>

<p><cite> Robert C. Martin </cite> in the chapter 1: Clean Code from the book by <a href="http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/">the same name</a></p></blockquote>

<p>Also, why should you estimate the new tiger team abilities better than the old tiger team? Is it because the language, tools, or just because they are &ldquo;plain better&rdquo;?</p>

<p>What guarantees that the resulting software is going to be better than the old one?</p>

<p>Another interesting definition of legacy code is Michael Feather&rsquo;s one (code without tests).</p>
]]></content>
  </entry>
  
</feed>
