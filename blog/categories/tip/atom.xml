<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tip | The long way through Software Craftsmanship]]></title>
  <link href="http://alvarogarcia7.github.io/blog/categories/tip/atom.xml" rel="self"/>
  <link href="http://alvarogarcia7.github.io/"/>
  <updated>2015-09-02T22:59:07+02:00</updated>
  <id>http://alvarogarcia7.github.io/</id>
  <author>
    <name><![CDATA[alvaro garcia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Searching on a Suite of Failing Tests]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/08/13/searching-on-a-suite-of-failing-tests/"/>
    <updated>2015-08-13T16:45:19+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/08/13/searching-on-a-suite-of-failing-tests</id>
    <content type="html"><![CDATA[<h2>Motivation</h2>

<p>Today, at a client, in the green phase, we had a test suite which was failing: the whole suite fails but the test cases, individually, succeed.</p>

<p>So my first impression was that something was being shared between tests. Also confirmed because the failing class was an EndToEnd test, in which we load the whole spring context</p>

<p>A quick glance was not revealing anything interesting, so I decided to find which is the minimum suite (as opposed as to the whole suite) that makes the new testcase fail, expecting to narrow the search for possible causes. This is very similar to what QuickCheck does, to generate the minimum testcase that breaks your property. In this way, you can focus in a possibly simpler<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> feature.</p>

<p>This post covers how to perform this search.</p>

<h2>Mathematical formulation</h2>

<p>Let <code>T</code> be a sequence of tests: <code>i1, i2, ..., in, F, j1, j2, ..., jm</code></p>

<p>where:
  * <code>i</code> are green tests
  *  <code>F</code> is first failing test
    * when executed in isolation, is green
    * when executed in the sequence, is red
  *  <code>j</code> are tests after the failed test.</p>

<p>In this case, the order is important, as the failed test suite (presumably) comes from a shared state set by a previous test.</p>

<p>The first search-space pruning is to remove the <code>j</code>, as they supposedly don&rsquo;t have any effect (as they are after the failed test)</p>

<p>let <code>T1</code> be a subsequence of <code>T</code> that includes <code>i</code> and <code>F</code>: <code>i1, i2, ..., in, F</code></p>

<p>Then it is assumed that one (or more) of the <code>i</code> generates an inconsistent state that makes <code>F</code> fail.</p>

<p>In the sequence <code>T1</code>, <code>F</code> fails, but in the sequence <code>TF</code> composed by <code>F</code> only, the test succeeds. This can be thought as the equivalent of the <a href="https://en.wikipedia.org/wiki/Intermediate_value_theorem">Intermediate value theorem</a>, also called Bolzano&rsquo;s theorem, where the <code>T1</code> is at one side ot the axis and the <code>TF</code> at another. The theorem proves that there must be at least one value where the domain of the function crosses the axis</p>

<p>I say &ldquo;thought of&rdquo; because that theorem is only for continous functions and sets are not (are discrete) but the analogy is good enough: if one sequence is OK but the other isn&rsquo;t, there must be a minimum sequence where the result is OK and another one where the results are not. They two sequences must not be the same case as one result cannot be OK and not OK at the same time.</p>

<h2>Naïve search</h2>

<p>The first way of searching would be find the minimum set that fails:</p>

<ul>
<li>include <code>F</code>, then another from <code>i1,...,in</code> that makes the <code>F</code> fail. <code>F</code> the last one, because it needs to be affected by the side effects from the preceding test.</li>
<li>if the first strategy does not work, for each of the above cases, add another from the <code>i1,...,in</code> (except the one that was added)</li>
</ul>


<p>For the first step, it takes <code>O(n * 2)</code>, assuming executing a single test costs <code>O(1)</code>. Reduces to <code>O(n)</code></p>

<p>For the second step, <code>O(n * n-1 * 3)</code>. Reduces to <code>O(n^2)</code></p>

<p>For the third step, <code>O(n * n-1 * n-2 * 4)</code>. Reduces to <code>O(n^3)</code></p>

<p>For the nth step, it costs <code>O(n * n-1 * n-2 * ... * n-(n-1) * (n+1))</code>. Reduces to <code>O(n^n)</code>. Which is polynomical but not feasible for medium-sized <code>n</code> (in an automatic fashion) or small <code>n</code> (in a manual fashion)</p>

<h2>Dichotomous search</h2>

<p>(This is also known as <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</a>)</p>

<p>Inspired by <code>git-bisect</code>, I decided to treat the sequence <code>i1, ..., in</code> as the source for the dicotomical search, applying the subsequences to <code>F</code>.</p>

<p>The first step, it takes <code>O(n/2 * n/2)</code> = <code>O(n^2)</code> to execute half the tests</p>

<p>The second step, is to execute half the number of the tests previously executed, either from the sequence before (if the <code>F</code> fails) or from the other half (if <code>F</code> does not fail). The cost is <code>O(n/4 * n/4)</code> = <code>O(n^2)</code></p>

<p>For the nth step, the cost is <code>O(n/2^n * n/2^n)</code> = <code>O(n^2/2^n)</code> = <code>O(0)</code></p>

<p>This n in the nth step is smaller than the other n, as each step divides by two the amount of tests to be included.</p>

<p>The amount of tests to be executed is <code>n + n/2 + n/4 + n/8 + ... + 1</code> which is roughly <code>2n</code>. Executing each test costs <code>O(1)</code> (by the assumption before), so the total cost is <code>O(2n)</code> = <code>O(n)</code></p>

<p>If we take it by the amount of steps we need to manually execute is 1 for the whole, 1 for the half, 1 for the quarter, &hellip;. = <code>O(log2 n)</code></p>

<h2>Procedure</h2>

<p>To keep the executed tests, I created a support branch where I deleted the tests that were selected to be excluded. Always executed &ldquo;all tests in the suite&rdquo; as this makes it faster to select in the IDE.</p>

<p>When the half taken was wrong, I reverted the last commit and selected the other half.</p>

<p>After finding the minimum sequence and solving the issue, this support branch was discarded</p>

<h2>Conclusion</h2>

<p>In the real scenario, with around 100 tests, searching manually in the naïve way would not have been possible. It would have cost 100 steps, as the minimum set that produces <code>F</code> had size 2 (so only one step was necessary).</p>

<p>Applying the dichotomous search, in 8-10 steps I had finished, with the guarantee that no matter how many tests produced the <code>F</code> I would have found it in a reasonable amount of time.</p>

<h2>Comments</h2>

<p>Finally, the root cause for the failing test <code>F</code> was the OrientDB InMemory implementation with Spring context, as the former does not allow two instances at the same time in the same JVM.</p>

<p>It was solved using <code>@DirtiesContext</code> in both cases of the minimum sequence that forms <code>F</code>, so no matter which order the executor decides, the context will always be clean for the next execution.</p>

<p>We found this thanks to a teammate&rsquo;s intuition.</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Because maybe the minimum testcase is more difficult than another.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiple Return Values in a Mockito Stub]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/08/07/multiple-values-in-a-mockito-stub/"/>
    <updated>2015-08-07T11:31:19+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/08/07/multiple-values-in-a-mockito-stub</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been asked today how to return multiple return values from a Mockito Spy, effectively using the spy as a Stub, as well.</p>

<pre><code class="java">package com.example.spike;

import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.is;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

import org.junit.Test;
import org.mockito.Spy;

public class DifferentReturnValues {

    @Spy
    private Spike1 spike1 = new Spike1();


    @Test
    public void spike1() {
        spike1 = spy(spike1);
        when(spike1.getBool()).thenReturn(false, true);

        assertThat(spike1.getBool(), is(false));
        assertThat(spike1.getBool(), is(true));

        assertThat(spike1.getBool(), is(true));
        assertThat(spike1.getBool(), is(true));
    }


    private class Spike1 {
        public boolean getBool() {
            return true;
        }
    }
}
</code></pre>

<p>The key line is:</p>

<pre><code class="java">when(spike1.getBool()).thenReturn(false, true);
</code></pre>

<p>this makes the stubbed function to return multiple values:</p>

<pre><code class="java">assertThat(spike1.getBool(), is(false));
assertThat(spike1.getBool(), is(true));
</code></pre>

<p>The last value is repeated after the last defined value:</p>

<pre><code class="java">@Test
public void spike1() {
    spike1 = spy(spike1);
    when(spike1.getBool()).thenReturn(false, true);

    assertThat(spike1.getBool(), is(false));
    assertThat(spike1.getBool(), is(true));

    assertThat(spike1.getBool(), is(true));
    assertThat(spike1.getBool(), is(true));
}
</code></pre>

<p>If you want to loop over the values, you can implement it with the <code>doAnswer</code> method:</p>

<pre><code class="java">@Test
public void spike1() {
    spike1 = spy(spike1);
    when(spike1.getBool()).thenReturn(false, true);

    final boolean[] value = {true};

    doAnswer(invocation -&gt; {
        value[0] = !value[0];
        return value[0];
    }).when(spike1).getBool();

    assertThat(spike1.getBool(), is(false));
    assertThat(spike1.getBool(), is(true));

    assertThat(spike1.getBool(), is(false));
    assertThat(spike1.getBool(), is(true));
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tip: Massively Reverting Local Changes]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/08/tip-massively-reverting-local-changes/"/>
    <updated>2015-07-08T02:40:24+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/08/tip-massively-reverting-local-changes</id>
    <content type="html"><![CDATA[<p>I was changing a massive amount of files (>1000) for a repeated code. The search and replace query was not too exact and it broke many tests in the system. For that, I preferred reverting those tests.</p>

<p>Here&rsquo;s how to do it automatically:</p>

<p>Copy all the failing tests to a text editor:</p>

<p>Input:</p>

<pre><code>testSearchXMLDocument(io.company.controller.dms.DocumentControllerTest)
testCreateXMLDocument(io.company.controller.dms.DocumentControllerTest)
testUpdateXFPageMetadata(io.company.controller.dms.DocumentControllerTest)
testCreateDocumentCrop(io.company.controller.dms.DocumentControllerTest)
testUpdateCropMetadata(io.company.controller.dms.DocumentControllerTest)
testDeleteDocument(io.company.controller.dms.DocumentControllerTest)
testUpdateXmlDocumentMetadata(io.company.controller.dms.DocumentControllerTest)
testUpdateXML(io.company.controller.dms.DocumentControllerTest)
testSearchXFPage(io.company.controller.dms.DocumentControllerTest)
testCreateXFPage(io.company.controller.dms.DocumentControllerTest)
testUpdatePage(io.company.controller.dms.DocumentControllerTest)
testSearchCrop(io.company.controller.dms.DocumentControllerTest)
testUpdateCrop(io.company.controller.dms.DocumentControllerTest)
testMoveDocument(io.company.controller.dms.DocumentControllerTest)
testGetDocument(io.company.controller.dms.DocumentControllerTest)
</code></pre>

<p>regex:</p>

<p>(tested in Sublime 3, build 3083, Windows 64)</p>

<p>find what: <code>^[^(]+\([a-Z.]*\.(.*)\)</code></p>

<p>replace with: <code>$1</code></p>

<p>Regex explanation for <code>^[^(]+\([a-Z.]*\.(.*)\)</code>:</p>

<ul>
<li><code>^</code>: beginning of line</li>
<li><code>[^(]+</code>: every character except parenthesis, one or more times</li>
<li><code>\([a-Z.]*</code>: start with one parenthesis, any number of a-z, A-Z</li>
<li>`.&#8220;: a dot, as I&rsquo;m using regex replacement</li>
<li><code>(.*)</code>: any character, zero or more times, captured in group <code>$1</code></li>
<li><code>\)</code>: closing parenthesis</li>
</ul>


<p>Output:</p>

<pre><code>DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
DocumentControllerTest
</code></pre>

<p>copy that to file <code>a.txt</code></p>

<p>Revert all the changes in these files:</p>

<pre><code class="bash">for i in $(cat a.txt | uniq); do
  git checkout -- *$i*
done
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tip: Committing to the Repo File by File]]></title>
    <link href="http://alvarogarcia7.github.io/blog/2015/07/08/tip-committing-to-the-repo-file-by-file/"/>
    <updated>2015-07-08T02:37:08+02:00</updated>
    <id>http://alvarogarcia7.github.io/blog/2015/07/08/tip-committing-to-the-repo-file-by-file</id>
    <content type="html"><![CDATA[<p>I was prefer committing to the repo with commits that are as small as possible as long as it makes sense. It makes it much easier to rever the changes.</p>

<p>This is why I have some scripts to commit all the changes, even with the same message. This is one of them:</p>

<pre><code class="bash">for f in $(git status -s |grep "^M"|awk '{print $2}'); do
  git add $f
  git commit -m "generic commit for all files"
done
</code></pre>
]]></content>
  </entry>
  
</feed>
